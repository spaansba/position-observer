"use strict";const p=e=>e!=null&&typeof e=="object"||!1,k=e=>p(e)&&typeof e.nodeType=="number"&&[1,2,3,4,5,6,7,8,9,10,11].some(t=>e.nodeType===t)||!1,a=e=>k(e)&&e.nodeType===1||!1,v=e=>typeof e=="function"||!1,d="1.0.8",f="PositionObserver Error";class y{entries;static version=d;_tick;_root;_callback;constructor(t,i){if(!v(t))throw new Error(`${f}: ${t} is not a function.`);this.entries=new Map,this._callback=t,this._root=a(i?.root)?i.root:document?.documentElement,this._tick=0}observe=t=>{if(!a(t))throw new Error(`${f}: ${t} is not an instance of Element.`);this._root.contains(t)&&this._new(t).then(({boundingClientRect:i})=>{if(i&&!this.getEntry(t)){const{clientWidth:n,clientHeight:s}=this._root;this.entries.set(t,{target:t,boundingClientRect:i,clientWidth:n,clientHeight:s})}this._tick||(this._tick=requestAnimationFrame(this._runCallback))})};unobserve=t=>{this.entries.has(t)&&this.entries.delete(t)};_runCallback=()=>{if(!this.entries.size)return;const{clientWidth:t,clientHeight:i}=this._root,n=new Promise(s=>{const o=[];this.entries.forEach(({target:r,boundingClientRect:c,clientWidth:u,clientHeight:_})=>{this._root.contains(r)&&this._new(r).then(({boundingClientRect:h,isIntersecting:m})=>{if(!m)return;const{left:b,top:w}=h;if(c.top!==w||c.left!==b||u!==t||_!==i){const l={target:r,boundingClientRect:h,clientHeight:i,clientWidth:t};this.entries.set(r,l),o.push(l)}})}),s(o)});this._tick=requestAnimationFrame(async()=>{const s=await n;s.length&&this._callback(s,this),this._runCallback()})};_new=t=>new Promise(i=>{new IntersectionObserver(([s],o)=>{o.disconnect(),i(s)}).observe(t)});getEntry=t=>this.entries.get(t);disconnect=()=>{cancelAnimationFrame(this._tick),this.entries.clear(),this._tick=0}}module.exports=y;
//# sourceMappingURL=index.cjs.map
