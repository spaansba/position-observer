{"version":3,"file":"index.mjs","sources":["../node_modules/.pnpm/@thednp+shorty@2.0.6/node_modules/@thednp/shorty/dist/shorty.mjs","../src/index.ts"],"sourcesContent":["const he = \"aria-checked\", ye = \"aria-description\", we = \"aria-describedby\", Ae = \"aria-expanded\", Se = \"aria-haspopup\", X = \"aria-hidden\", Ne = \"aria-label\", Te = \"aria-labelledby\", Me = \"aria-modal\", ke = \"aria-pressed\", De = \"aria-selected\", Ce = \"aria-valuemin\", Oe = \"aria-valuemax\", Le = \"aria-valuenow\", Ie = \"aria-valuetext\", Y = \"abort\", Z = \"beforeunload\", _ = \"blur\", $ = \"change\", tt = \"contextmenu\", P = \"DOMContentLoaded\", et = \"DOMMouseScroll\", nt = \"error\", ot = \"focus\", st = \"focusin\", ct = \"focusout\", rt = \"gesturechange\", at = \"gestureend\", it = \"gesturestart\", ut = \"keydown\", lt = \"keypress\", dt = \"keyup\", pt = \"load\", ft = \"click\", mt = \"dblclick\", gt = \"mousedown\", vt = \"mouseup\", Et = \"hover\", bt = \"mouseenter\", ht = \"mouseleave\", yt = \"mousein\", wt = \"mouseout\", At = \"mouseover\", St = \"mousemove\", Nt = \"mousewheel\", Tt = \"move\", Mt = \"orientationchange\", kt = \"pointercancel\", Dt = \"pointerdown\", Ct = \"pointerleave\", Ot = \"pointermove\", Lt = \"pointerup\", It = \"readystatechange\", xt = \"reset\", zt = \"resize\", Vt = \"select\", Bt = \"selectend\", Ft = \"selectstart\", Ht = \"scroll\", Pt = \"submit\", Ut = \"touchstart\", Wt = \"touchmove\", Rt = \"touchcancel\", Qt = \"touchend\", jt = \"unload\", xe = {\n  DOMContentLoaded: P,\n  DOMMouseScroll: et,\n  abort: Y,\n  beforeunload: Z,\n  blur: _,\n  change: $,\n  click: ft,\n  contextmenu: tt,\n  dblclick: mt,\n  error: nt,\n  focus: ot,\n  focusin: st,\n  focusout: ct,\n  gesturechange: rt,\n  gestureend: at,\n  gesturestart: it,\n  hover: Et,\n  keydown: ut,\n  keypress: lt,\n  keyup: dt,\n  load: pt,\n  mousedown: gt,\n  mousemove: St,\n  mousein: yt,\n  mouseout: wt,\n  mouseenter: bt,\n  mouseleave: ht,\n  mouseover: At,\n  mouseup: vt,\n  mousewheel: Nt,\n  move: Tt,\n  orientationchange: Mt,\n  pointercancel: kt,\n  pointerdown: Dt,\n  pointerleave: Ct,\n  pointermove: Ot,\n  pointerup: Lt,\n  readystatechange: It,\n  reset: xt,\n  resize: zt,\n  scroll: Ht,\n  select: Vt,\n  selectend: Bt,\n  selectstart: Ft,\n  submit: Pt,\n  touchcancel: Rt,\n  touchend: Qt,\n  touchmove: Wt,\n  touchstart: Ut,\n  unload: jt\n}, ze = \"drag\", Ve = \"dragstart\", Be = \"dragenter\", Fe = \"dragleave\", He = \"dragover\", Pe = \"dragend\", Ue = \"loadstart\", We = {\n  start: \"mousedown\",\n  end: \"mouseup\",\n  move: \"mousemove\",\n  cancel: \"mouseleave\"\n}, Re = { down: \"mousedown\", up: \"mouseup\" }, Qe = \"onmouseleave\" in document ? [\"mouseenter\", \"mouseleave\"] : (\n  /* istanbul ignore next @preserve */\n  [\"mouseover\", \"mouseout\"]\n), je = {\n  start: \"touchstart\",\n  end: \"touchend\",\n  move: \"touchmove\",\n  cancel: \"touchcancel\"\n}, qe = { in: \"focusin\", out: \"focusout\" }, qt = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"]', Ge = {\n  Backspace: \"Backspace\",\n  //  8\n  Tab: \"Tab\",\n  //  9\n  Enter: \"Enter\",\n  // 13\n  Shift: \"Shift\",\n  // 16\n  Control: \"Control\",\n  // 17\n  Alt: \"Alt\",\n  // 18\n  Pause: \"Pause\",\n  // 19\n  CapsLock: \"CapsLock\",\n  // 20\n  Escape: \"Escape\",\n  // 27\n  Scape: \"Space\",\n  // 32\n  ArrowLeft: \"ArrowLeft\",\n  // 37\n  ArrowUp: \"ArrowUp\",\n  // 38\n  ArrowRight: \"ArrowRight\",\n  // 39\n  ArrowDown: \"ArrowDown\",\n  // 40\n  Insert: \"Insert\",\n  // 45\n  Delete: \"Delete\",\n  // 46\n  Meta: \"Meta\",\n  // 91 windows key\n  ContextMenu: \"ContextMenu\",\n  // 93\n  ScrollLock: \"ScrollLock\"\n  // 145\n}, Ke = \"Alt\", Je = \"ArrowDown\", Xe = \"ArrowUp\", Ye = \"ArrowLeft\", Ze = \"ArrowRight\", _e = \"Backspace\", $e = \"CapsLock\", tn = \"Control\", en = \"Delete\", nn = \"Enter\", on = \"NumpadEnter\", sn = \"Escape\", cn = \"Insert\", rn = \"Meta\", an = \"Pause\", un = \"ScrollLock\", ln = \"Shift\", dn = \"Space\", pn = \"Tab\", Gt = \"animationDuration\", Kt = \"animationDelay\", U = \"animationName\", D = \"animationend\", Jt = \"transitionDuration\", Xt = \"transitionDelay\", C = \"transitionend\", W = \"transitionProperty\", fn = \"addEventListener\", mn = \"removeEventListener\", gn = {\n  linear: \"linear\",\n  easingSinusoidalIn: \"cubic-bezier(0.47,0,0.745,0.715)\",\n  easingSinusoidalOut: \"cubic-bezier(0.39,0.575,0.565,1)\",\n  easingSinusoidalInOut: \"cubic-bezier(0.445,0.05,0.55,0.95)\",\n  easingQuadraticIn: \"cubic-bezier(0.550,0.085,0.680,0.530)\",\n  easingQuadraticOut: \"cubic-bezier(0.250,0.460,0.450,0.940)\",\n  easingQuadraticInOut: \"cubic-bezier(0.455,0.030,0.515,0.955)\",\n  easingCubicIn: \"cubic-bezier(0.55,0.055,0.675,0.19)\",\n  easingCubicOut: \"cubic-bezier(0.215,0.61,0.355,1)\",\n  easingCubicInOut: \"cubic-bezier(0.645,0.045,0.355,1)\",\n  easingQuarticIn: \"cubic-bezier(0.895,0.03,0.685,0.22)\",\n  easingQuarticOut: \"cubic-bezier(0.165,0.84,0.44,1)\",\n  easingQuarticInOut: \"cubic-bezier(0.77,0,0.175,1)\",\n  easingQuinticIn: \"cubic-bezier(0.755,0.05,0.855,0.06)\",\n  easingQuinticOut: \"cubic-bezier(0.23,1,0.32,1)\",\n  easingQuinticInOut: \"cubic-bezier(0.86,0,0.07,1)\",\n  easingExponentialIn: \"cubic-bezier(0.95,0.05,0.795,0.035)\",\n  easingExponentialOut: \"cubic-bezier(0.19,1,0.22,1)\",\n  easingExponentialInOut: \"cubic-bezier(1,0,0,1)\",\n  easingCircularIn: \"cubic-bezier(0.6,0.04,0.98,0.335)\",\n  easingCircularOut: \"cubic-bezier(0.075,0.82,0.165,1)\",\n  easingCircularInOut: \"cubic-bezier(0.785,0.135,0.15,0.86)\",\n  easingBackIn: \"cubic-bezier(0.6,-0.28,0.735,0.045)\",\n  easingBackOut: \"cubic-bezier(0.175,0.885,0.32,1.275)\",\n  easingBackInOut: \"cubic-bezier(0.68,-0.55,0.265,1.55)\"\n}, vn = \"offsetHeight\", En = \"offsetWidth\", bn = \"scrollHeight\", hn = \"scrollWidth\", yn = \"tabindex\", Yt = navigator.userAgentData, A = Yt, { userAgent: Zt } = navigator, S = Zt, z = /iPhone|iPad|iPod|Android/i;\nlet O = !1;\n// istanbul ignore else @preserve\nA ? O = A.brands.some((t) => z.test(t.brand)) : O = z.test(S);\nconst wn = O, V = /(iPhone|iPod|iPad)/, An = A ? A.brands.some(\n  (t) => V.test(t.brand)\n) : (\n  /* istanbul ignore next @preserve */\n  V.test(S)\n), Sn = S ? S.includes(\"Firefox\") : (\n  /* istanbul ignore next @preserve */\n  !1\n), { head: N } = document, Nn = [\"webkitPerspective\", \"perspective\"].some(\n  (t) => t in N.style\n), R = (t, e, n, o) => {\n  const s = o || !1;\n  t.addEventListener(\n    e,\n    n,\n    s\n  );\n}, Q = (t, e, n, o) => {\n  const s = o || !1;\n  t.removeEventListener(\n    e,\n    n,\n    s\n  );\n}, _t = (t, e, n, o) => {\n  const s = (c) => {\n    // istanbul ignore else @preserve\n    (c.target === t || c.currentTarget === t) && (n.apply(t, [c]), Q(t, e, s, o));\n  };\n  R(t, e, s, o);\n}, $t = () => {\n}, Tn = (() => {\n  let t = !1;\n  try {\n    const e = Object.defineProperty({}, \"passive\", {\n      get: () => (t = !0, t)\n    });\n    // istanbul ignore next @preserve\n    _t(document, P, $t, e);\n  } catch {\n  }\n  return t;\n})(), Mn = [\"webkitTransform\", \"transform\"].some(\n  (t) => t in N.style\n), kn = \"ontouchstart\" in window || /* istanbul ignore next @preserve */\n\"msMaxTouchPoints\" in navigator, Dn = [\"webkitAnimation\", \"animation\"].some(\n  (t) => t in N.style\n), Cn = [\"webkitTransition\", \"transition\"].some(\n  (t) => t in N.style\n), j = (t, e) => t.getAttribute(e), On = (t, e, n) => e.getAttributeNS(t, n), te = (t, e) => t.hasAttribute(e), Ln = (t, e, n) => e.hasAttributeNS(t, n), In = (t, e, n) => t.setAttribute(e, n), xn = (t, e, n, o) => e.setAttributeNS(t, n, o), zn = (t, e) => t.removeAttribute(e), Vn = (t, e, n) => e.removeAttributeNS(t, n), Bn = (t, ...e) => {\n  t.classList.add(...e);\n}, Fn = (t, ...e) => {\n  t.classList.remove(...e);\n}, Hn = (t, e) => t.classList.contains(e), { body: Pn } = document, { documentElement: Un } = document, Wn = (t) => Array.from(t), v = (t) => t != null && typeof t == \"object\" || !1, i = (t) => v(t) && typeof t.nodeType == \"number\" && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].some(\n  (e) => t.nodeType === e\n) || !1, l = (t) => i(t) && t.nodeType === 1 || !1, E = /* @__PURE__ */ new Map(), L = {\n  data: E,\n  /**\n   * Sets web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @param instance the component instance\n   */\n  set: (t, e, n) => {\n    if (!l(t)) return;\n    // istanbul ignore else @preserve\n    E.has(e) || E.set(e, /* @__PURE__ */ new Map()), E.get(e).set(t, n);\n  },\n  /**\n   * Returns all instances for specified component.\n   *\n   * @param component the component's name or a unique key\n   * @returns all the component instances\n   */\n  getAllFor: (t) => E.get(t) || null,\n  /**\n   * Returns the instance associated with the target.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @returns the instance\n   */\n  get: (t, e) => {\n    if (!l(t) || !e) return null;\n    const n = L.getAllFor(e);\n    return t && n && n.get(t) || null;\n  },\n  /**\n   * Removes web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   */\n  remove: (t, e) => {\n    const n = L.getAllFor(e);\n    if (!n || !l(t)) return;\n    n.delete(t);\n    // istanbul ignore else @preserve\n    n.size === 0 && E.delete(e);\n  }\n}, Rn = (t, e) => L.get(t, e), T = (t) => typeof t == \"string\" || !1, q = (t) => v(t) && t.constructor.name === \"Window\" || !1, G = (t) => i(t) && t.nodeType === 9 || !1, d = (t) => q(t) ? t.document : G(t) ? t : i(t) ? t.ownerDocument : globalThis.document, M = (t, ...e) => Object.assign(t, ...e), ee = (t) => {\n  if (!t) return;\n  if (T(t))\n    return d().createElement(t);\n  const { tagName: e } = t, n = ee(e);\n  if (!n) return;\n  const o = { ...t };\n  return delete o.tagName, M(n, o);\n}, ne = (t, e) => {\n  if (!t || !e) return;\n  if (T(e))\n    return d().createElementNS(t, e);\n  const { tagName: n } = e, o = ne(t, n);\n  if (!o) return;\n  const s = { ...e };\n  return delete s.tagName, M(o, s);\n}, K = (t, e) => t.dispatchEvent(e), Qn = (t, e, n) => n.indexOf(t) === e, g = (t, e) => {\n  const n = getComputedStyle(t), o = e.replace(\"webkit\", \"Webkit\").replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  return n.getPropertyValue(o);\n}, oe = (t) => {\n  const e = g(t, U), n = g(t, Kt), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : 0;\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, se = (t) => {\n  const e = g(t, U), n = g(t, Gt), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : 0;\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, jn = (t, e) => {\n  let n = 0;\n  const o = new Event(D), s = se(t), c = oe(t);\n  if (s) {\n    const a = (u) => {\n      // istanbul ignore else @preserve\n      u.target === t && (e.apply(t, [u]), t.removeEventListener(D, a), n = 1);\n    };\n    t.addEventListener(D, a), setTimeout(() => {\n      // istanbul ignore next @preserve\n      n || K(t, o);\n    }, s + c + 17);\n  } else {\n    // istanbul ignore next @preserve\n    e.apply(t, [o]);\n  }\n}, ce = (t) => {\n  const e = g(t, W), n = g(t, Xt), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : (\n    /* istanbul ignore next */\n    0\n  );\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, re = (t) => {\n  const e = g(t, W), n = g(t, Jt), o = n.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : (\n    /* istanbul ignore next */\n    0\n  );\n  return Number.isNaN(s) ? (\n    /* istanbul ignore next */\n    0\n  ) : s;\n}, qn = (t, e) => {\n  let n = 0;\n  const o = new Event(C), s = re(t), c = ce(t);\n  if (s) {\n    const a = (u) => {\n      // istanbul ignore else @preserve\n      u.target === t && (e.apply(t, [u]), t.removeEventListener(C, a), n = 1);\n    };\n    t.addEventListener(C, a), setTimeout(() => {\n      // istanbul ignore next @preserve\n      n || K(t, o);\n    }, s + c + 17);\n  } else\n    e.apply(t, [o]);\n}, Gn = (t) => Float32Array.from(Array.from(t)), Kn = (t) => Float64Array.from(Array.from(t)), Jn = (t, e) => t.focus(e), B = (t) => [\"true\", !0].includes(t) ? !0 : [\"false\", !1].includes(t) ? !1 : [\"null\", \"\", null, void 0].includes(t) ? null : t !== \"\" && !Number.isNaN(+t) ? +t : t, w = (t) => Object.entries(t), ae = (t) => t.toLowerCase(), Xn = (t, e, n, o) => {\n  const s = { ...n }, c = { ...t.dataset }, a = { ...e }, u = {}, p = \"title\";\n  return w(c).forEach(([r, f]) => {\n    const y = o && typeof r == \"string\" && r.includes(o) ? r.replace(o, \"\").replace(\n      /[A-Z]/g,\n      (J) => ae(J)\n    ) : (\n      /* istanbul ignore next @preserve */\n      r\n    );\n    u[y] = B(f);\n  }), w(s).forEach(([r, f]) => {\n    s[r] = B(f);\n  }), w(e).forEach(([r, f]) => {\n    // istanbul ignore else @preserve\n    r in s ? a[r] = s[r] : r in u ? a[r] = u[r] : a[r] = r === p ? j(t, p) : f;\n  }), a;\n}, Yn = (t, e) => v(t) && (Object.hasOwn(t, e) || e in t), Zn = (t) => Object.keys(t), _n = (t) => Object.values(t), $n = (t) => Object.fromEntries(t), to = (t, e) => {\n  const n = new CustomEvent(t, {\n    cancelable: !0,\n    bubbles: !0\n  });\n  // istanbul ignore else @preserve\n  return v(e) && M(n, e), n;\n}, eo = { passive: !0 }, no = (t) => t.offsetHeight, oo = (t, e) => {\n  w(e).forEach(([n, o]) => {\n    if (o && T(n) && n.includes(\"--\"))\n      t.style.setProperty(n, o);\n    else {\n      const s = {};\n      s[n] = o, M(t.style, s);\n    }\n  });\n}, I = (t) => v(t) && t.constructor.name === \"Map\" || !1, ie = (t) => typeof t == \"number\" || !1, m = /* @__PURE__ */ new Map(), so = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   *\n   * @param element target element\n   * @param callback the callback\n   * @param delay the execution delay\n   * @param key a unique key\n   */\n  set: (t, e, n, o) => {\n    if (!l(t)) return;\n    // istanbul ignore else @preserve\n    if (o && o.length) {\n      // istanbul ignore else @preserve\n      m.has(t) || m.set(t, /* @__PURE__ */ new Map()), m.get(t).set(o, setTimeout(e, n));\n    } else\n      m.set(t, setTimeout(e, n));\n  },\n  /**\n   * Returns the timer associated with the target.\n   *\n   * @param element target element\n   * @param key a unique\n   * @returns the timer\n   */\n  get: (t, e) => {\n    if (!l(t)) return null;\n    const n = m.get(t);\n    return e && n && I(n) ? n.get(e) || /* istanbul ignore next @preserve */\n    null : ie(n) ? n : null;\n  },\n  /**\n   * Clears the element's timer.\n   *\n   * @param element target element\n   * @param key a unique key\n   */\n  clear: (t, e) => {\n    if (!l(t)) return;\n    const n = m.get(t);\n    if (e && e.length && I(n)) {\n      clearTimeout(n.get(e)), n.delete(e);\n      // istanbul ignore else @preserve\n      n.size === 0 && m.delete(t);\n    } else\n      clearTimeout(n), m.delete(t);\n  }\n}, co = (t) => t.toUpperCase(), ue = (t, e) => (i(e) ? e : d()).querySelectorAll(t), x = /* @__PURE__ */ new Map();\nfunction le(t) {\n  const { shiftKey: e, code: n } = t, o = d(this), s = [\n    ...ue(qt, this)\n  ].filter(\n    (u) => !te(u, \"disabled\") && !j(u, X)\n  );\n  if (!s.length) return;\n  const c = s[0], a = s[s.length - 1];\n  // istanbul ignore else @preserve\n  n === \"Tab\" && (e && o.activeElement === c ? (a.focus(), t.preventDefault()) : !e && o.activeElement === a && (c.focus(), t.preventDefault()));\n}\nconst de = (t) => x.has(t) === !0, ro = (t) => {\n  const e = de(t);\n  (e ? Q : R)(t, \"keydown\", le), e ? x.delete(t) : x.set(t, !0);\n}, h = (t, e) => {\n  const { width: n, height: o, top: s, right: c, bottom: a, left: u } = t.getBoundingClientRect();\n  let p = 1, r = 1;\n  if (e && l(t)) {\n    const { offsetWidth: f, offsetHeight: y } = t;\n    p = f > 0 ? Math.round(n) / f : (\n      /* istanbul ignore next @preserve */\n      1\n    ), r = y > 0 ? Math.round(o) / y : (\n      /* istanbul ignore next @preserve */\n      1\n    );\n  }\n  return {\n    width: n / p,\n    height: o / r,\n    top: s / r,\n    right: c / p,\n    bottom: a / r,\n    left: u / p,\n    x: u / p,\n    y: s / r\n  };\n}, ao = (t) => d(t).body, k = (t) => d(t).documentElement, io = (t) => d(t).head, uo = (t) => {\n  const e = q(t), n = e ? t.scrollX : t.scrollLeft, o = e ? t.scrollY : t.scrollTop;\n  return { x: n, y: o };\n}, pe = (t) => i(t) && t.constructor.name === \"ShadowRoot\" || !1, lo = (t) => t.nodeName === \"HTML\" ? t : l(t) && t.assignedSlot || // step into the shadow DOM of the parent of a slotted node\ni(t) && t.parentNode || // DOM Element detected\npe(t) && t.host || // ShadowRoot detected\nk(t), fe = (t) => {\n  if (!l(t)) return !1;\n  const { width: e, height: n } = h(t), { offsetWidth: o, offsetHeight: s } = t;\n  return Math.round(e) !== o || Math.round(n) !== s;\n}, po = (t, e, n) => {\n  const o = l(e), s = h(\n    t,\n    o && fe(e)\n  ), c = { x: 0, y: 0 };\n  // istanbul ignore else @preserve\n  if (o) {\n    const a = h(e, !0);\n    c.x = a.x + e.clientLeft, c.y = a.y + e.clientTop;\n  }\n  return {\n    x: s.left + n.x - c.x,\n    y: s.top + n.y - c.y,\n    width: s.width,\n    height: s.height\n  };\n};\nlet F = 0, H = 0;\nconst b = /* @__PURE__ */ new Map(), me = (t, e) => {\n  let n = e ? F : H;\n  if (e) {\n    const o = me(t), s = b.get(o) || /* @__PURE__ */ new Map();\n    b.has(o) || b.set(o, s), I(s) && !s.has(e) ? (s.set(e, n), F += 1) : n = s.get(e);\n  } else {\n    const o = t.id || t;\n    b.has(o) ? n = b.get(o) : (b.set(o, n), H += 1);\n  }\n  return n;\n}, fo = (t) => t ? G(t) ? t.defaultView : i(t) ? t?.ownerDocument?.defaultView : t : window, ge = (t) => Array.isArray(t) || !1, mo = (t) => i(t) && t.nodeName === \"CANVAS\" || !1, ve = (t) => l(t) && !!t.shadowRoot || !1, go = (t) => i(t) && [1, 2, 3, 4, 5, 6, 7, 8].some((e) => t.nodeType === e) || !1, vo = (t) => {\n  if (!i(t)) return !1;\n  const { top: e, bottom: n } = h(t), { clientHeight: o } = k(t);\n  return e <= o && n >= 0;\n}, Eo = (t) => {\n  if (!i(t)) return !1;\n  const { clientWidth: e, clientHeight: n } = k(t), { top: o, left: s, bottom: c, right: a } = h(t, !0);\n  return o >= 0 && s >= 0 && c <= n && a <= e;\n}, bo = (t) => ge(t) && t.every(l) || !1, ho = (t) => typeof t == \"function\" || !1, yo = (t) => v(t) && t.constructor.name === \"HTMLCollection\" || !1, wo = (t) => l(t) && t.tagName === \"IMG\" || !1, Ao = (t) => {\n  if (!T(t)) return !1;\n  try {\n    JSON.parse(t);\n  } catch {\n    return !1;\n  }\n  return !0;\n}, So = (t) => v(t) && t.constructor.name === \"WeakMap\" || !1, No = (t) => i(t) && [\"SVG\", \"Image\", \"Video\", \"Canvas\"].some(\n  (e) => t.constructor.name.includes(e)\n) || !1, To = (t) => v(t) && t.constructor.name === \"NodeList\" || !1, Mo = (t) => k(t).dir === \"rtl\", ko = (t) => i(t) && t.constructor.name.includes(\"SVG\") || !1, Do = (t) => i(t) && [\"TABLE\", \"TD\", \"TH\"].includes(t.nodeName) || !1, Ee = (t, e) => t ? t.closest(e) || // break out of `ShadowRoot`\nEe(t.getRootNode().host, e) : null, Co = (t, e) => l(t) ? t : (i(e) ? e : d()).querySelector(t), be = (t, e) => (i(e) ? e : d()).getElementsByTagName(\n  t\n), Oo = (t) => [...be(\"*\", t)].filter(ve), Lo = (t, e) => d(e).getElementById(t) || null, Io = (t, e) => (e && i(e) ? e : d()).getElementsByClassName(\n  t\n), xo = (t, e) => t.matches(e), zo = \"2.0.6\";\nexport {\n  Wn as ArrayFrom,\n  P as DOMContentLoadedEvent,\n  et as DOMMouseScrollEvent,\n  L as Data,\n  Gn as Float32ArrayFrom,\n  Kn as Float64ArrayFrom,\n  M as ObjectAssign,\n  w as ObjectEntries,\n  $n as ObjectFromEntries,\n  Yn as ObjectHasOwn,\n  Zn as ObjectKeys,\n  _n as ObjectValues,\n  so as Timer,\n  Y as abortEvent,\n  Bn as addClass,\n  fn as addEventListener,\n  Kt as animationDelay,\n  Gt as animationDuration,\n  D as animationEndEvent,\n  U as animationName,\n  he as ariaChecked,\n  we as ariaDescribedBy,\n  ye as ariaDescription,\n  Ae as ariaExpanded,\n  Se as ariaHasPopup,\n  X as ariaHidden,\n  Ne as ariaLabel,\n  Te as ariaLabelledBy,\n  Me as ariaModal,\n  ke as ariaPressed,\n  De as ariaSelected,\n  Oe as ariaValueMax,\n  Ce as ariaValueMin,\n  Le as ariaValueNow,\n  Ie as ariaValueText,\n  Z as beforeunloadEvent,\n  gn as bezierEasings,\n  _ as blurEvent,\n  $ as changeEvent,\n  Ee as closest,\n  tt as contextmenuEvent,\n  to as createCustomEvent,\n  ee as createElement,\n  ne as createElementNS,\n  K as dispatchEvent,\n  Qn as distinct,\n  Pn as documentBody,\n  Un as documentElement,\n  N as documentHead,\n  ze as dragEvent,\n  Pe as dragendEvent,\n  Be as dragenterEvent,\n  Fe as dragleaveEvent,\n  He as dragoverEvent,\n  Ve as dragstartEvent,\n  jn as emulateAnimationEnd,\n  qn as emulateTransitionEnd,\n  nt as errorEvent,\n  Jn as focus,\n  ot as focusEvent,\n  qe as focusEvents,\n  qt as focusableSelector,\n  st as focusinEvent,\n  ct as focusoutEvent,\n  rt as gesturechangeEvent,\n  at as gestureendEvent,\n  it as gesturestartEvent,\n  j as getAttribute,\n  On as getAttributeNS,\n  h as getBoundingClientRect,\n  Oo as getCustomElements,\n  d as getDocument,\n  ao as getDocumentBody,\n  k as getDocumentElement,\n  io as getDocumentHead,\n  oe as getElementAnimationDelay,\n  se as getElementAnimationDuration,\n  Lo as getElementById,\n  g as getElementStyle,\n  ce as getElementTransitionDelay,\n  re as getElementTransitionDuration,\n  Io as getElementsByClassName,\n  be as getElementsByTagName,\n  Rn as getInstance,\n  uo as getNodeScroll,\n  lo as getParentNode,\n  po as getRectRelativeToOffsetParent,\n  me as getUID,\n  fo as getWindow,\n  te as hasAttribute,\n  Ln as hasAttributeNS,\n  Hn as hasClass,\n  de as hasFocusTrap,\n  An as isApple,\n  ge as isArray,\n  mo as isCanvas,\n  ve as isCustomElement,\n  G as isDocument,\n  go as isElement,\n  vo as isElementInScrollRange,\n  Eo as isElementInViewport,\n  bo as isElementsArray,\n  Sn as isFirefox,\n  ho as isFunction,\n  yo as isHTMLCollection,\n  l as isHTMLElement,\n  wo as isHTMLImageElement,\n  Ao as isJSON,\n  I as isMap,\n  No as isMedia,\n  wn as isMobile,\n  i as isNode,\n  To as isNodeList,\n  ie as isNumber,\n  v as isObject,\n  Mo as isRTL,\n  ko as isSVGElement,\n  fe as isScaledElement,\n  pe as isShadowRoot,\n  T as isString,\n  Do as isTableElement,\n  So as isWeakMap,\n  q as isWindow,\n  Ke as keyAlt,\n  Je as keyArrowDown,\n  Ye as keyArrowLeft,\n  Ze as keyArrowRight,\n  Xe as keyArrowUp,\n  _e as keyBackspace,\n  $e as keyCapsLock,\n  tn as keyControl,\n  en as keyDelete,\n  nn as keyEnter,\n  sn as keyEscape,\n  cn as keyInsert,\n  rn as keyMeta,\n  on as keyNumpadEnter,\n  an as keyPause,\n  un as keyScrollLock,\n  ln as keyShift,\n  dn as keySpace,\n  pn as keyTab,\n  Ge as keyboardEventKeys,\n  ut as keydownEvent,\n  lt as keypressEvent,\n  dt as keyupEvent,\n  pt as loadEvent,\n  Ue as loadstartEvent,\n  xo as matches,\n  Re as mouseClickEvents,\n  Qe as mouseHoverEvents,\n  We as mouseSwipeEvents,\n  ft as mouseclickEvent,\n  mt as mousedblclickEvent,\n  gt as mousedownEvent,\n  bt as mouseenterEvent,\n  Et as mousehoverEvent,\n  yt as mouseinEvent,\n  ht as mouseleaveEvent,\n  St as mousemoveEvent,\n  wt as mouseoutEvent,\n  At as mouseoverEvent,\n  vt as mouseupEvent,\n  Nt as mousewheelEvent,\n  Tt as moveEvent,\n  xe as nativeEvents,\n  $t as noop,\n  Xn as normalizeOptions,\n  B as normalizeValue,\n  Q as off,\n  vn as offsetHeight,\n  En as offsetWidth,\n  R as on,\n  _t as one,\n  Mt as orientationchangeEvent,\n  eo as passiveHandler,\n  kt as pointercancelEvent,\n  Dt as pointerdownEvent,\n  Ct as pointerleaveEvent,\n  Ot as pointermoveEvent,\n  Lt as pointerupEvent,\n  Co as querySelector,\n  ue as querySelectorAll,\n  It as readystatechangeEvent,\n  no as reflow,\n  zn as removeAttribute,\n  Vn as removeAttributeNS,\n  Fn as removeClass,\n  mn as removeEventListener,\n  xt as resetEvent,\n  zt as resizeEvent,\n  Ht as scrollEvent,\n  bn as scrollHeight,\n  hn as scrollWidth,\n  Vt as selectEvent,\n  Bt as selectendEvent,\n  Ft as selectstartEvent,\n  In as setAttribute,\n  xn as setAttributeNS,\n  oo as setElementStyle,\n  Pt as submitEvent,\n  Nn as support3DTransform,\n  Dn as supportAnimation,\n  Tn as supportPassive,\n  kn as supportTouch,\n  Mn as supportTransform,\n  Cn as supportTransition,\n  yn as tabindex,\n  ae as toLowerCase,\n  co as toUpperCase,\n  ro as toggleFocusTrap,\n  je as touchEvents,\n  Rt as touchcancelEvent,\n  Qt as touchendEvent,\n  Wt as touchmoveEvent,\n  Ut as touchstartEvent,\n  Xt as transitionDelay,\n  Jt as transitionDuration,\n  C as transitionEndEvent,\n  W as transitionProperty,\n  jt as unloadEvent,\n  S as userAgent,\n  A as userAgentData,\n  zo as version\n};\n//# sourceMappingURL=shorty.mjs.map\n","import {\n  getBoundingClientRect,\n  isFunction,\n  isHTMLElement,\n} from \"@thednp/shorty\";\n\nexport type PositionObserverCallback = (\n  entries: PositionObserverEntry[],\n) => void;\nexport type PositionObserverEntry = {\n  target: HTMLElement;\n  boundingBox: DOMRect;\n  isVisible: boolean;\n};\nexport type PositionObserverOptions = {\n  root: HTMLElement;\n};\n\nconst errorString = \"PositionObserver Error\";\n\n/**\n * The PositionObserver class is a utility class that observes the position\n * of DOM elements and triggers a callback when their position changes.\n */\nexport default class PositionObserver {\n  public entries: PositionObserverEntry[];\n  private _tick: number;\n  private _root: HTMLElement;\n  private _callback: PositionObserverCallback;\n\n  /**\n   * The constructor takes two arguments, a `callback`, which is called\n   * whenever the position of an observed element changes and an `options` object.\n   * The callback function should take an array of `PositionObserverEntry` objects\n   * as its only argument, but it's not required.\n   *\n   * @param callback the callback that applies to all targets of this observer\n   * @param options the options of this observer\n   */\n  constructor(\n    callback: PositionObserverCallback,\n    options?: Partial<PositionObserverOptions>,\n  ) {\n    if (!isFunction(callback)) {\n      throw new Error(`${errorString}: ${callback} is not a function.`);\n    }\n    this.entries = [];\n    this._callback = callback;\n    // viewport is basically \"unknown\" at this point\n    this._root = isHTMLElement(options?.root)\n      ? options.root\n      /* istanbul ignore next @preserve */\n      : document?.documentElement;\n    this._tick = 0;\n  }\n\n  /**\n   * Start observing the position of the specified element.\n   * If the element is not currently attached to the DOM,\n   * it will NOT be added to the entries.\n   * @param target\n   */\n  public observe = (target: HTMLElement) => {\n    if (!isHTMLElement(target)) {\n      throw new Error(\n        `${errorString}: ${target} is not an instance of HTMLElement.`,\n      );\n    }\n\n    /* istanbul ignore if @preserve - a guard must be set */\n    if (!this._root.contains(target)) return;\n\n    const { clientWidth, clientHeight } = this._root;\n    const boundingBox = getBoundingClientRect(target) as DOMRect;\n    const { left, top, bottom, right, width, height } = boundingBox;\n\n    const isVisible = top > 1 - height && left > 1 - width &&\n      bottom <= clientHeight + height - 1 && right <= clientWidth + width - 1;\n\n    this.entries.push({ target, boundingBox, isVisible });\n    /* istanbul ignore else @preserve */\n    if (!this._tick) {\n      this._tick = requestAnimationFrame(this._runCallback);\n    }\n  };\n\n  /**\n   * Stop observing the position of the specified element.\n   * @param target\n   */\n  public unobserve = (target: HTMLElement) => {\n    const index = this.entries.findIndex((e) => e.target === target);\n    this.entries.splice(index, 1);\n  };\n\n  /**\n   * Private method responsible for all the heavy duty.\n   */\n  private _runCallback = () => {\n    /* istanbul ignore if @preserve - a guard must be set */\n    if (!this.entries.length) return;\n    const updates: PositionObserverEntry[] = [];\n    // the viewport is known at this point\n    const { clientWidth, clientHeight } = this._root as HTMLElement;\n\n    this.entries.forEach((entry, index) => {\n      const { target, boundingBox: oldBoundingBox } = entry;\n      const boundingBox = getBoundingClientRect(target) as DOMRect;\n      const { left, top, bottom, right, width, height } = boundingBox;\n\n      if (\n        oldBoundingBox.left !== left || oldBoundingBox.top !== top ||\n        oldBoundingBox.right !== right || oldBoundingBox.bottom !== bottom\n      ) {\n        const isVisible = top > 1 - height && left > 1 - width &&\n          bottom <= clientHeight + height - 1 &&\n          right <= clientWidth + width - 1;\n\n        this.entries[index].boundingBox = boundingBox;\n        this.entries[index].isVisible = isVisible;\n        updates.push({ target, boundingBox, isVisible });\n      }\n    });\n\n    // only execute the callback if position actually changed\n    if (updates.length) {\n      this._callback(updates);\n    }\n    requestAnimationFrame(this._runCallback);\n  };\n\n  /**\n   * Immediately stop observing all elements.\n   */\n  public disconnect = () => {\n    cancelAnimationFrame(this._tick);\n    this.entries.length = 0;\n    this._tick = 0;\n  };\n}\n"],"names":["P","Yt","A","Zt","S","z","V","N","R","n","o","s","Q","_t","c","$t","v","i","l","h","a","u","p","r","ho","errorString","PositionObserver","callback","options","__publicField","target","isHTMLElement","clientWidth","clientHeight","boundingBox","getBoundingClientRect","left","top","bottom","right","width","height","isVisible","index","e","updates","entry","oldBoundingBox","isFunction"],"mappings":"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","x_google_ignoreList":[0]}