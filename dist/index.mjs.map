{"version":3,"file":"index.mjs","sources":["../node_modules/.pnpm/@thednp+shorty@https+++codeload.github.com+thednp+shorty+tar.gz+9f449c30fcab6456b44d59e763a130fd6821a830/node_modules/@thednp/shorty/dist/shorty.mjs","../src/index.ts"],"sourcesContent":["const Ce = \"2.0.8\", Te = \"aria-checked\", Me = \"aria-description\", De = \"aria-describedby\", Le = \"aria-expanded\", Oe = \"aria-haspopup\", $ = \"aria-hidden\", xe = \"aria-label\", ze = \"aria-labelledby\", Ie = \"aria-modal\", Pe = \"aria-pressed\", Fe = \"aria-selected\", Be = \"aria-valuemin\", Ve = \"aria-valuemax\", He = \"aria-valuenow\", Ue = \"aria-valuetext\", J = \"abort\", X = \"beforeunload\", Y = \"blur\", tt = \"change\", et = \"contextmenu\", V = \"DOMContentLoaded\", nt = \"DOMMouseScroll\", ot = \"error\", st = \"focus\", rt = \"focusin\", ct = \"focusout\", at = \"gesturechange\", it = \"gestureend\", ut = \"gesturestart\", lt = \"keydown\", dt = \"keypress\", ft = \"keyup\", pt = \"load\", gt = \"click\", mt = \"dblclick\", vt = \"mousedown\", bt = \"mouseup\", Et = \"hover\", ht = \"mouseenter\", yt = \"mouseleave\", wt = \"mousein\", At = \"mouseout\", St = \"mouseover\", kt = \"mousemove\", Nt = \"mousewheel\", Ct = \"move\", Tt = \"orientationchange\", Mt = \"pointercancel\", Dt = \"pointerdown\", Lt = \"pointerleave\", Ot = \"pointermove\", xt = \"pointerup\", zt = \"readystatechange\", It = \"reset\", Pt = \"resize\", Ft = \"select\", Bt = \"selectend\", Vt = \"selectstart\", Ht = \"scroll\", Ut = \"submit\", Wt = \"touchstart\", Rt = \"touchmove\", Qt = \"touchcancel\", jt = \"touchend\", Kt = \"unload\", We = {\n  DOMContentLoaded: V,\n  DOMMouseScroll: nt,\n  abort: J,\n  beforeunload: X,\n  blur: Y,\n  change: tt,\n  click: gt,\n  contextmenu: et,\n  dblclick: mt,\n  error: ot,\n  focus: st,\n  focusin: rt,\n  focusout: ct,\n  gesturechange: at,\n  gestureend: it,\n  gesturestart: ut,\n  hover: Et,\n  keydown: lt,\n  keypress: dt,\n  keyup: ft,\n  load: pt,\n  mousedown: vt,\n  mousemove: kt,\n  mousein: wt,\n  mouseout: At,\n  mouseenter: ht,\n  mouseleave: yt,\n  mouseover: St,\n  mouseup: bt,\n  mousewheel: Nt,\n  move: Ct,\n  orientationchange: Tt,\n  pointercancel: Mt,\n  pointerdown: Dt,\n  pointerleave: Lt,\n  pointermove: Ot,\n  pointerup: xt,\n  readystatechange: zt,\n  reset: It,\n  resize: Pt,\n  scroll: Ht,\n  select: Ft,\n  selectend: Bt,\n  selectstart: Vt,\n  submit: Ut,\n  touchcancel: Qt,\n  touchend: jt,\n  touchmove: Rt,\n  touchstart: Wt,\n  unload: Kt\n}, Re = \"drag\", Qe = \"dragstart\", je = \"dragenter\", Ke = \"dragleave\", qe = \"dragover\", Ge = \"dragend\", Ze = \"loadstart\", _e = {\n  start: \"mousedown\",\n  end: \"mouseup\",\n  move: \"mousemove\",\n  cancel: \"mouseleave\"\n}, $e = { down: \"mousedown\", up: \"mouseup\" }, Je = \"onmouseleave\" in document ? [\"mouseenter\", \"mouseleave\"] : [\"mouseover\", \"mouseout\"], Xe = {\n  start: \"touchstart\",\n  end: \"touchend\",\n  move: \"touchmove\",\n  cancel: \"touchcancel\"\n}, Ye = { in: \"focusin\", out: \"focusout\" }, qt = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"]', tn = {\n  Backspace: \"Backspace\",\n  Tab: \"Tab\",\n  Enter: \"Enter\",\n  Shift: \"Shift\",\n  Control: \"Control\",\n  Alt: \"Alt\",\n  Pause: \"Pause\",\n  CapsLock: \"CapsLock\",\n  Escape: \"Escape\",\n  Scape: \"Space\",\n  ArrowLeft: \"ArrowLeft\",\n  ArrowUp: \"ArrowUp\",\n  ArrowRight: \"ArrowRight\",\n  ArrowDown: \"ArrowDown\",\n  Insert: \"Insert\",\n  Delete: \"Delete\",\n  Meta: \"Meta\",\n  ContextMenu: \"ContextMenu\",\n  ScrollLock: \"ScrollLock\"\n}, en = \"Alt\", nn = \"ArrowDown\", on = \"ArrowUp\", sn = \"ArrowLeft\", rn = \"ArrowRight\", cn = \"Backspace\", an = \"CapsLock\", un = \"Control\", ln = \"Delete\", dn = \"Enter\", fn = \"NumpadEnter\", pn = \"Escape\", gn = \"Insert\", mn = \"Meta\", vn = \"Pause\", bn = \"ScrollLock\", En = \"Shift\", hn = \"Space\", yn = \"Tab\", Gt = \"animationDuration\", Zt = \"animationDelay\", H = \"animationName\", T = \"animationend\", _t = \"transitionDuration\", $t = \"transitionDelay\", M = \"transitionend\", U = \"transitionProperty\", wn = \"addEventListener\", An = \"removeEventListener\", Sn = {\n  linear: \"linear\",\n  easingSinusoidalIn: \"cubic-bezier(0.47,0,0.745,0.715)\",\n  easingSinusoidalOut: \"cubic-bezier(0.39,0.575,0.565,1)\",\n  easingSinusoidalInOut: \"cubic-bezier(0.445,0.05,0.55,0.95)\",\n  easingQuadraticIn: \"cubic-bezier(0.550,0.085,0.680,0.530)\",\n  easingQuadraticOut: \"cubic-bezier(0.250,0.460,0.450,0.940)\",\n  easingQuadraticInOut: \"cubic-bezier(0.455,0.030,0.515,0.955)\",\n  easingCubicIn: \"cubic-bezier(0.55,0.055,0.675,0.19)\",\n  easingCubicOut: \"cubic-bezier(0.215,0.61,0.355,1)\",\n  easingCubicInOut: \"cubic-bezier(0.645,0.045,0.355,1)\",\n  easingQuarticIn: \"cubic-bezier(0.895,0.03,0.685,0.22)\",\n  easingQuarticOut: \"cubic-bezier(0.165,0.84,0.44,1)\",\n  easingQuarticInOut: \"cubic-bezier(0.77,0,0.175,1)\",\n  easingQuinticIn: \"cubic-bezier(0.755,0.05,0.855,0.06)\",\n  easingQuinticOut: \"cubic-bezier(0.23,1,0.32,1)\",\n  easingQuinticInOut: \"cubic-bezier(0.86,0,0.07,1)\",\n  easingExponentialIn: \"cubic-bezier(0.95,0.05,0.795,0.035)\",\n  easingExponentialOut: \"cubic-bezier(0.19,1,0.22,1)\",\n  easingExponentialInOut: \"cubic-bezier(1,0,0,1)\",\n  easingCircularIn: \"cubic-bezier(0.6,0.04,0.98,0.335)\",\n  easingCircularOut: \"cubic-bezier(0.075,0.82,0.165,1)\",\n  easingCircularInOut: \"cubic-bezier(0.785,0.135,0.15,0.86)\",\n  easingBackIn: \"cubic-bezier(0.6,-0.28,0.735,0.045)\",\n  easingBackOut: \"cubic-bezier(0.175,0.885,0.32,1.275)\",\n  easingBackInOut: \"cubic-bezier(0.68,-0.55,0.265,1.55)\"\n}, kn = \"offsetHeight\", Nn = \"offsetWidth\", Cn = \"scrollHeight\", Tn = \"scrollWidth\", Mn = \"tabindex\", Dn = navigator.userAgentData, { userAgent: Jt } = navigator, Ln = Jt, On = () => {\n  const t = /iPhone|iPad|iPod|Android/i;\n  return navigator?.userAgentData?.brands.some(\n    (e) => t.test(e.brand)\n  ) || t.test(navigator?.userAgent) || !1;\n}, xn = () => {\n  const t = /(iPhone|iPod|iPad)/;\n  return navigator?.userAgentData?.brands.some(\n    (e) => t.test(e.brand)\n  ) || t.test(\n    navigator?.userAgent\n  ) || !1;\n}, zn = () => navigator?.userAgent?.includes(\"Firefox\") || !1, Xt = () => typeof CSS > \"u\" || !CSS.supports ? !1 : CSS.supports(\"-webkit-backdrop-filter\", \"none\"), In = () => [\"webkitPerspective\", \"perspective\"].some((t) => t in document.head.style), Yt = () => {\n}, W = (t, e, n, o) => {\n  const s = o || !1;\n  t.addEventListener(\n    e,\n    n,\n    s\n  );\n}, R = (t, e, n, o) => {\n  const s = o || !1;\n  t.removeEventListener(\n    e,\n    n,\n    s\n  );\n}, te = (t, e, n, o) => {\n  const s = (r) => {\n    (r.target === t || r.currentTarget === t) && (n.apply(t, [r]), R(t, e, s, o));\n  };\n  W(t, e, s, o);\n}, Pn = () => {\n  let t = !1;\n  try {\n    const e = Object.defineProperty({}, \"passive\", {\n      get: () => (t = !0, t)\n    });\n    te(document, V, Yt, e);\n  } catch {\n  }\n  return t;\n}, Fn = () => [\"webkitTransform\", \"transform\"].some((t) => t in document.head.style), Bn = () => \"ontouchstart\" in window || \"msMaxTouchPoints\" in navigator, Vn = () => [\"webkitAnimation\", \"animation\"].some((t) => t in document.head.style), Hn = () => [\"webkitTransition\", \"transition\"].some((t) => t in document.head.style), Q = (t, e) => t.getAttribute(e), Un = (t, e, n) => e.getAttributeNS(t, n), ee = (t, e) => t.hasAttribute(e), Wn = (t, e, n) => e.hasAttributeNS(t, n), Rn = (t, e, n) => t.setAttribute(e, n), Qn = (t, e, n, o) => e.setAttributeNS(t, n, o), jn = (t, e) => t.removeAttribute(e), Kn = (t, e, n) => e.removeAttributeNS(t, n), qn = (t, ...e) => {\n  t.classList.add(...e);\n}, Gn = (t, ...e) => {\n  t.classList.remove(...e);\n}, Zn = (t, e) => t.classList.contains(e), { body: _n } = document, { documentElement: $n } = document, { head: Jn } = document, Xn = (t) => Array.from(t), v = (t) => t != null && typeof t == \"object\" || !1, u = (t) => v(t) && typeof t.nodeType == \"number\" && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].some(\n  (e) => t.nodeType === e\n) || !1, i = (t) => u(t) && t.nodeType === 1 || !1, E = /* @__PURE__ */ new Map(), L = {\n  data: E,\n  /**\n   * Sets web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @param instance the component instance\n   */\n  set: (t, e, n) => {\n    if (!i(t)) return;\n    E.has(e) || E.set(e, /* @__PURE__ */ new Map()), E.get(e).set(t, n);\n  },\n  /**\n   * Returns all instances for specified component.\n   *\n   * @param component the component's name or a unique key\n   * @returns all the component instances\n   */\n  getAllFor: (t) => E.get(t) || null,\n  /**\n   * Returns the instance associated with the target.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @returns the instance\n   */\n  get: (t, e) => {\n    if (!i(t) || !e) return null;\n    const n = L.getAllFor(e);\n    return t && n && n.get(t) || null;\n  },\n  /**\n   * Removes web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   */\n  remove: (t, e) => {\n    const n = L.getAllFor(e);\n    !n || !i(t) || (n.delete(t), n.size === 0 && E.delete(e));\n  }\n}, Yn = (t, e) => L.get(t, e), to = (t) => t?.charAt(0).toUpperCase() + t?.slice(1), eo = (t) => t?.trim().replace(\n  /(?:^\\w|[A-Z]|\\b\\w)/g,\n  (e, n) => n === 0 ? e.toLowerCase() : e.toUpperCase()\n).replace(/\\s+/g, \"\"), N = (t) => typeof t == \"string\" || !1, j = (t) => v(t) && t.constructor.name === \"Window\" || !1, K = (t) => u(t) && t.nodeType === 9 || !1, d = (t) => j(t) ? t.document : K(t) ? t : u(t) ? t.ownerDocument : globalThis.document, C = (t, ...e) => Object.assign(t, ...e), ne = (t) => {\n  if (!t) return;\n  if (N(t))\n    return d().createElement(t);\n  const { tagName: e } = t, n = ne(e);\n  if (!n) return;\n  const o = { ...t };\n  return delete o.tagName, C(n, o);\n}, oe = (t, e) => {\n  if (!t || !e) return;\n  if (N(e))\n    return d().createElementNS(t, e);\n  const { tagName: n } = e, o = oe(t, n);\n  if (!o) return;\n  const s = { ...e };\n  return delete s.tagName, C(o, s);\n}, q = (t, e) => t.dispatchEvent(e), no = (t, e, n) => n.indexOf(t) === e, f = (t, e) => {\n  const n = getComputedStyle(t), o = e.replace(\"webkit\", \"Webkit\").replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  return n.getPropertyValue(o);\n}, se = (t) => {\n  const e = f(t, H), n = f(t, Zt), o = n.includes(\"ms\") ? 1 : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : 0;\n  return Number.isNaN(s) ? 0 : s;\n}, re = (t) => {\n  const e = f(t, H), n = f(t, Gt), o = n.includes(\"ms\") ? 1 : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : 0;\n  return Number.isNaN(s) ? 0 : s;\n}, oo = (t, e) => {\n  let n = 0;\n  const o = new Event(T), s = re(t), r = se(t);\n  if (s) {\n    const a = (l) => {\n      l.target === t && (e.apply(t, [l]), t.removeEventListener(T, a), n = 1);\n    };\n    t.addEventListener(T, a), setTimeout(() => {\n      n || q(t, o);\n    }, s + r + 17);\n  } else\n    e.apply(t, [o]);\n}, ce = (t) => {\n  const e = f(t, U), n = f(t, $t), o = n.includes(\"ms\") ? 1 : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : 0;\n  return Number.isNaN(s) ? 0 : s;\n}, ae = (t) => {\n  const e = f(t, U), n = f(t, _t), o = n.includes(\"ms\") ? 1 : 1e3, s = e && e !== \"none\" ? parseFloat(n) * o : 0;\n  return Number.isNaN(s) ? 0 : s;\n}, so = (t, e) => {\n  let n = 0;\n  const o = new Event(M), s = ae(t), r = ce(t);\n  if (s) {\n    const a = (l) => {\n      l.target === t && (e.apply(t, [l]), t.removeEventListener(M, a), n = 1);\n    };\n    t.addEventListener(M, a), setTimeout(() => {\n      n || q(t, o);\n    }, s + r + 17);\n  } else\n    e.apply(t, [o]);\n}, ro = (t) => Float32Array.from(Array.from(t)), co = (t) => Float64Array.from(Array.from(t)), ao = (t, e) => t.focus(e), io = (t) => t?.trim().replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/\\s+/g, \"-\").toLowerCase(), I = (t) => [\"true\", !0].includes(t) ? !0 : [\"false\", !1].includes(t) ? !1 : [\"null\", \"\", null, void 0].includes(t) ? null : t !== \"\" && !Number.isNaN(+t) ? +t : t, S = (t) => Object.entries(t), ie = (t) => t.toLowerCase(), uo = (t, e, n, o) => {\n  if (!i(t)) return e;\n  const s = { ...n }, r = { ...t.dataset }, a = { ...e }, l = {}, p = \"title\";\n  return S(r).forEach(([c, g]) => {\n    const A = o && typeof c == \"string\" && c.includes(o) ? c.replace(o, \"\").replace(\n      /[A-Z]/g,\n      (_) => ie(_)\n    ) : c;\n    l[A] = I(g);\n  }), S(s).forEach(([c, g]) => {\n    s[c] = I(g);\n  }), S(e).forEach(([c, g]) => {\n    c in s ? a[c] = s[c] : c in l ? a[c] = l[c] : a[c] = c === p ? Q(t, p) : g;\n  }), a;\n}, lo = (t, e) => v(t) && (Object.hasOwn(t, e) || e in t), fo = (t) => Object.keys(t), po = (t) => Object.values(t), go = (t) => Object.fromEntries(t), mo = (t, e) => {\n  const n = new CustomEvent(t, {\n    cancelable: !0,\n    bubbles: !0\n  });\n  return v(e) && C(n, e), n;\n}, vo = { passive: !0 }, bo = (t) => t.offsetHeight, Eo = (t, e) => {\n  S(e).forEach(([n, o]) => {\n    if (o && N(n) && n.includes(\"--\"))\n      t.style.setProperty(n, o);\n    else {\n      const s = {};\n      s[n] = o, C(t.style, s);\n    }\n  });\n}, O = (t) => v(t) && t.constructor.name === \"Map\" || !1, ue = (t) => typeof t == \"number\" || !1, m = /* @__PURE__ */ new Map(), ho = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   *\n   * @param element target element\n   * @param callback the callback\n   * @param delay the execution delay\n   * @param key a unique key\n   */\n  set: (t, e, n, o) => {\n    i(t) && (o && o.length ? (m.has(t) || m.set(t, /* @__PURE__ */ new Map()), m.get(t).set(o, setTimeout(e, n))) : m.set(t, setTimeout(e, n)));\n  },\n  /**\n   * Returns the timer associated with the target.\n   *\n   * @param element target element\n   * @param key a unique\n   * @returns the timer\n   */\n  get: (t, e) => {\n    if (!i(t)) return null;\n    const n = m.get(t);\n    return e && n && O(n) ? n.get(e) || null : ue(n) ? n : null;\n  },\n  /**\n   * Clears the element's timer.\n   *\n   * @param element target element\n   * @param key a unique key\n   */\n  clear: (t, e) => {\n    if (!i(t)) return;\n    const n = m.get(t);\n    e && e.length && O(n) ? (clearTimeout(n.get(e)), n.delete(e), n.size === 0 && m.delete(t)) : (clearTimeout(n), m.delete(t));\n  }\n}, yo = (t) => t.toUpperCase(), le = (t, e) => (u(e) ? e : d()).querySelectorAll(t), x = /* @__PURE__ */ new Map();\nfunction de(t) {\n  const { shiftKey: e, code: n } = t, o = d(this), s = [\n    ...le(qt, this)\n  ].filter(\n    (l) => !ee(l, \"disabled\") && !Q(l, $)\n  );\n  if (!s.length) return;\n  const r = s[0], a = s[s.length - 1];\n  n === \"Tab\" && (e && o.activeElement === r ? (a.focus(), t.preventDefault()) : !e && o.activeElement === a && (r.focus(), t.preventDefault()));\n}\nconst fe = (t) => x.has(t) === !0, wo = (t) => {\n  const e = fe(t);\n  (e ? R : W)(t, \"keydown\", de), e ? x.delete(t) : x.set(t, !0);\n}, b = (t) => i(t) && \"offsetWidth\" in t || !1, y = (t, e) => {\n  const { width: n, height: o, top: s, right: r, bottom: a, left: l } = t.getBoundingClientRect();\n  let p = 1, c = 1;\n  if (e && b(t)) {\n    const { offsetWidth: g, offsetHeight: A } = t;\n    p = g > 0 ? Math.round(n) / g : 1, c = A > 0 ? Math.round(o) / A : 1;\n  }\n  return {\n    width: n / p,\n    height: o / c,\n    top: s / c,\n    right: r / p,\n    bottom: a / c,\n    left: l / p,\n    x: l / p,\n    y: s / c\n  };\n}, Ao = (t) => d(t).body, w = (t) => d(t).documentElement, So = (t) => d(t).head, pe = (t) => u(t) ? (t.nodeName || \"\").toLowerCase() : \"#document\", ko = (t) => {\n  const e = j(t), n = e ? t.scrollX : t.scrollLeft, o = e ? t.scrollY : t.scrollTop;\n  return { x: n, y: o };\n}, ge = (t) => u(t) && t.constructor.name === \"ShadowRoot\" || !1, k = (t) => t.nodeName === \"HTML\" ? t : i(t) && t.assignedSlot || u(t) && t.parentNode || ge(t) && t.host || w(t), me = (t) => t ? K(t) ? t.defaultView : u(t) ? t?.ownerDocument?.defaultView : t : window, ve = (t) => u(t) && [\"TABLE\", \"TD\", \"TH\"].includes(t.nodeName) || !1, be = (t, e) => t.matches(e), D = (t) => f(t, \"position\") === \"static\", Ee = (t) => f(t, \"position\") === \"fixed\", G = (t) => [\":popover-open\", \":modal\"].some((e) => {\n  try {\n    return be(t, e);\n  } catch {\n    return !1;\n  }\n}), Z = (t) => {\n  const e = Xt(), n = i(t) ? getComputedStyle(t) : t;\n  return n.transform !== \"none\" || n.perspective !== \"none\" || (n.containerType ? n.containerType !== \"normal\" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== \"none\" : !1) || !e && (n.filter ? n.filter !== \"none\" : !1) || [\"transform\", \"perspective\", \"filter\"].some(\n    (o) => (n.willChange || \"\").includes(o)\n  ) || [\"paint\", \"layout\", \"strict\", \"content\"].some(\n    (o) => (n.contain || \"\").includes(o)\n  );\n}, he = (t) => {\n  let e = k(t);\n  for (; i(e) && !z(e); ) {\n    if (Z(e))\n      return e;\n    if (G(e))\n      return null;\n    e = k(e);\n  }\n  return null;\n}, z = (t) => [\"html\", \"body\", \"#document\"].includes(pe(t)), P = (t) => {\n  if (!b(t) || Ee(t))\n    return null;\n  let e = t.offsetParent;\n  return w(t) === e && (e = e.ownerDocument.body), e;\n}, No = (t) => {\n  const e = me(t);\n  if (!u(t) || G(t))\n    return e;\n  if (!b(t)) {\n    let o = k(t);\n    for (; o && !z(o); ) {\n      if (i(o) && !D(o))\n        return o;\n      o = k(o);\n    }\n    return e;\n  }\n  let n = P(t);\n  for (; n && ve(n) && D(n); )\n    n = P(n);\n  return n && z(n) && D(n) && !Z(n) ? e : n || he(t) || e;\n}, ye = (t) => {\n  if (!b(t)) return !1;\n  const { width: e, height: n } = y(t), { offsetWidth: o, offsetHeight: s } = t;\n  return Math.round(e) !== o || Math.round(n) !== s;\n}, Co = (t, e, n) => {\n  const o = b(e), s = y(\n    t,\n    o && ye(e)\n  ), r = { x: 0, y: 0 };\n  if (o) {\n    const a = y(e, !0);\n    r.x = a.x + e.clientLeft, r.y = a.y + e.clientTop;\n  }\n  return {\n    x: s.left + n.x - r.x,\n    y: s.top + n.y - r.y,\n    width: s.width,\n    height: s.height\n  };\n};\nlet F = 0, B = 0;\nconst h = /* @__PURE__ */ new Map(), we = (t, e) => {\n  let n = e ? F : B;\n  if (e) {\n    const o = we(t), s = h.get(o) || /* @__PURE__ */ new Map();\n    h.has(o) || h.set(o, s), O(s) && !s.has(e) ? (s.set(e, n), F += 1) : n = s.get(e);\n  } else {\n    const o = t.id || t;\n    h.has(o) ? n = h.get(o) : (h.set(o, n), B += 1);\n  }\n  return n;\n}, Ae = (t) => Array.isArray(t) || !1, To = (t) => u(t) && t.nodeName === \"CANVAS\" || !1, Se = (t) => b(t) && !!t.shadowRoot || !1, Mo = (t) => {\n  if (!u(t)) return !1;\n  const { top: e, bottom: n } = y(t), { clientHeight: o } = w(t);\n  return e <= o && n >= 0;\n}, Do = (t) => {\n  if (!i(t)) return !1;\n  const { clientWidth: e, clientHeight: n } = w(t), { top: o, left: s, bottom: r, right: a } = y(t, !0);\n  return o >= 0 && s >= 0 && r <= n && a <= e;\n}, Lo = (t) => Ae(t) && t.every(i) || !1, Oo = (t) => typeof t == \"function\" || !1, xo = (t) => v(t) && t.constructor.name === \"HTMLCollection\" || !1, zo = (t) => b(t) && t.tagName === \"IMG\" || !1, Io = (t) => {\n  if (!N(t)) return !1;\n  try {\n    JSON.parse(t);\n  } catch {\n    return !1;\n  }\n  return !0;\n}, Po = (t) => v(t) && t.constructor.name === \"WeakMap\" || !1, Fo = (t) => u(t) && [\"SVG\", \"Image\", \"Video\", \"Canvas\"].some(\n  (e) => t.constructor.name.includes(e)\n) || !1, Bo = (t) => v(t) && t.constructor.name === \"NodeList\" || !1, Vo = (t) => w(t).dir === \"rtl\", Ho = (t) => u(t) && t.constructor.name.includes(\"SVG\") || !1, ke = (t, e) => !t || !e ? null : t.closest(e) || ke(t.getRootNode().host, e) || null, Uo = (t, e) => i(t) ? t : (i(e) ? e : d()).querySelector(t), Ne = (t, e) => (u(e) ? e : d()).getElementsByTagName(\n  t\n), Wo = (t) => [...Ne(\"*\", t)].filter(Se), Ro = (t, e) => d(e).getElementById(t), Qo = (t, e) => (e && u(e) ? e : d()).getElementsByClassName(\n  t\n);\nexport {\n  Xn as ArrayFrom,\n  V as DOMContentLoadedEvent,\n  nt as DOMMouseScrollEvent,\n  L as Data,\n  ro as Float32ArrayFrom,\n  co as Float64ArrayFrom,\n  C as ObjectAssign,\n  S as ObjectEntries,\n  go as ObjectFromEntries,\n  lo as ObjectHasOwn,\n  fo as ObjectKeys,\n  po as ObjectValues,\n  ho as Timer,\n  J as abortEvent,\n  qn as addClass,\n  wn as addEventListener,\n  Zt as animationDelay,\n  Gt as animationDuration,\n  T as animationEndEvent,\n  H as animationName,\n  Te as ariaChecked,\n  De as ariaDescribedBy,\n  Me as ariaDescription,\n  Le as ariaExpanded,\n  Oe as ariaHasPopup,\n  $ as ariaHidden,\n  xe as ariaLabel,\n  ze as ariaLabelledBy,\n  Ie as ariaModal,\n  Pe as ariaPressed,\n  Fe as ariaSelected,\n  Ve as ariaValueMax,\n  Be as ariaValueMin,\n  He as ariaValueNow,\n  Ue as ariaValueText,\n  X as beforeunloadEvent,\n  Sn as bezierEasings,\n  Y as blurEvent,\n  eo as camelCase,\n  to as capitalize,\n  tt as changeEvent,\n  ke as closest,\n  et as contextmenuEvent,\n  mo as createCustomEvent,\n  ne as createElement,\n  oe as createElementNS,\n  q as dispatchEvent,\n  no as distinct,\n  _n as documentBody,\n  $n as documentElement,\n  Jn as documentHead,\n  Re as dragEvent,\n  Ge as dragendEvent,\n  je as dragenterEvent,\n  Ke as dragleaveEvent,\n  qe as dragoverEvent,\n  Qe as dragstartEvent,\n  oo as emulateAnimationEnd,\n  so as emulateTransitionEnd,\n  ot as errorEvent,\n  ao as focus,\n  st as focusEvent,\n  Ye as focusEvents,\n  qt as focusableSelector,\n  rt as focusinEvent,\n  ct as focusoutEvent,\n  at as gesturechangeEvent,\n  it as gestureendEvent,\n  ut as gesturestartEvent,\n  Q as getAttribute,\n  Un as getAttributeNS,\n  y as getBoundingClientRect,\n  Wo as getCustomElements,\n  d as getDocument,\n  Ao as getDocumentBody,\n  w as getDocumentElement,\n  So as getDocumentHead,\n  se as getElementAnimationDelay,\n  re as getElementAnimationDuration,\n  Ro as getElementById,\n  f as getElementStyle,\n  ce as getElementTransitionDelay,\n  ae as getElementTransitionDuration,\n  Qo as getElementsByClassName,\n  Ne as getElementsByTagName,\n  Yn as getInstance,\n  pe as getNodeName,\n  ko as getNodeScroll,\n  No as getOffsetParent,\n  k as getParentNode,\n  Co as getRectRelativeToOffsetParent,\n  we as getUID,\n  me as getWindow,\n  ee as hasAttribute,\n  Wn as hasAttributeNS,\n  Zn as hasClass,\n  fe as hasFocusTrap,\n  xn as isApple,\n  Ae as isArray,\n  To as isCanvas,\n  Se as isCustomElement,\n  K as isDocument,\n  i as isElement,\n  Mo as isElementInScrollRange,\n  Do as isElementInViewport,\n  Lo as isElementsArray,\n  zn as isFirefox,\n  Oo as isFunction,\n  xo as isHTMLCollection,\n  b as isHTMLElement,\n  zo as isHTMLImageElement,\n  Io as isJSON,\n  O as isMap,\n  Fo as isMedia,\n  On as isMobile,\n  u as isNode,\n  Bo as isNodeList,\n  ue as isNumber,\n  v as isObject,\n  Vo as isRTL,\n  Ho as isSVGElement,\n  ye as isScaledElement,\n  ge as isShadowRoot,\n  N as isString,\n  ve as isTableElement,\n  Po as isWeakMap,\n  Xt as isWebKit,\n  j as isWindow,\n  io as kebabCase,\n  en as keyAlt,\n  nn as keyArrowDown,\n  sn as keyArrowLeft,\n  rn as keyArrowRight,\n  on as keyArrowUp,\n  cn as keyBackspace,\n  an as keyCapsLock,\n  un as keyControl,\n  ln as keyDelete,\n  dn as keyEnter,\n  pn as keyEscape,\n  gn as keyInsert,\n  mn as keyMeta,\n  fn as keyNumpadEnter,\n  vn as keyPause,\n  bn as keyScrollLock,\n  En as keyShift,\n  hn as keySpace,\n  yn as keyTab,\n  tn as keyboardEventKeys,\n  lt as keydownEvent,\n  dt as keypressEvent,\n  ft as keyupEvent,\n  pt as loadEvent,\n  Ze as loadstartEvent,\n  be as matches,\n  $e as mouseClickEvents,\n  Je as mouseHoverEvents,\n  _e as mouseSwipeEvents,\n  gt as mouseclickEvent,\n  mt as mousedblclickEvent,\n  vt as mousedownEvent,\n  ht as mouseenterEvent,\n  Et as mousehoverEvent,\n  wt as mouseinEvent,\n  yt as mouseleaveEvent,\n  kt as mousemoveEvent,\n  At as mouseoutEvent,\n  St as mouseoverEvent,\n  bt as mouseupEvent,\n  Nt as mousewheelEvent,\n  Ct as moveEvent,\n  We as nativeEvents,\n  Yt as noop,\n  uo as normalizeOptions,\n  I as normalizeValue,\n  R as off,\n  kn as offsetHeight,\n  Nn as offsetWidth,\n  W as on,\n  te as one,\n  Tt as orientationchangeEvent,\n  vo as passiveHandler,\n  Mt as pointercancelEvent,\n  Dt as pointerdownEvent,\n  Lt as pointerleaveEvent,\n  Ot as pointermoveEvent,\n  xt as pointerupEvent,\n  Uo as querySelector,\n  le as querySelectorAll,\n  zt as readystatechangeEvent,\n  bo as reflow,\n  jn as removeAttribute,\n  Kn as removeAttributeNS,\n  Gn as removeClass,\n  An as removeEventListener,\n  It as resetEvent,\n  Pt as resizeEvent,\n  Ht as scrollEvent,\n  Cn as scrollHeight,\n  Tn as scrollWidth,\n  Ft as selectEvent,\n  Bt as selectendEvent,\n  Vt as selectstartEvent,\n  Rn as setAttribute,\n  Qn as setAttributeNS,\n  Eo as setElementStyle,\n  Ut as submitEvent,\n  In as support3DTransform,\n  Vn as supportAnimation,\n  Pn as supportPassive,\n  Bn as supportTouch,\n  Fn as supportTransform,\n  Hn as supportTransition,\n  Mn as tabindex,\n  ie as toLowerCase,\n  yo as toUpperCase,\n  wo as toggleFocusTrap,\n  Xe as touchEvents,\n  Qt as touchcancelEvent,\n  jt as touchendEvent,\n  Rt as touchmoveEvent,\n  Wt as touchstartEvent,\n  $t as transitionDelay,\n  _t as transitionDuration,\n  M as transitionEndEvent,\n  U as transitionProperty,\n  Kt as unloadEvent,\n  Ln as userAgent,\n  Dn as userAgentData,\n  Ce as version\n};\n//# sourceMappingURL=shorty.mjs.map\n","import { isElement, isFunction } from \"@thednp/shorty\";\nimport { version } from \"../package.json\";\n\nexport type PositionObserverCallback = (\n  entries: PositionObserverEntry[],\n  observer: PositionObserver,\n) => void;\n\nexport type PositionObserverEntry = {\n  target: Element;\n  boundingClientRect: DOMRect;\n  isVisible: boolean;\n};\n\nexport type PositionObserverOptions = {\n  root: HTMLElement;\n};\n\nconst errorString = \"PositionObserver Error\";\n\n/**\n * The PositionObserver class is a utility class that observes the position\n * of DOM elements and triggers a callback when their position changes.\n */\nexport default class PositionObserver {\n  public entries: Map<Element, PositionObserverEntry>;\n  public static version = version;\n  private _tick: number;\n  private _root: Element;\n  private _callback: PositionObserverCallback;\n\n  /**\n   * The constructor takes two arguments, a `callback`, which is called\n   * whenever the position of an observed element changes and an `options` object.\n   * The callback function should take an array of `PositionObserverEntry` objects\n   * as its only argument, but it's not required.\n   *\n   * @param callback the callback that applies to all targets of this observer\n   * @param options the options of this observer\n   */\n  constructor(\n    callback: PositionObserverCallback,\n    options?: Partial<PositionObserverOptions>,\n  ) {\n    if (!isFunction(callback)) {\n      throw new Error(`${errorString}: ${callback} is not a function.`);\n    }\n    this.entries = new Map();\n    this._callback = callback;\n    this._root = isElement(options?.root)\n      ? options.root\n      /* istanbul ignore next @preserve */\n      : document?.documentElement;\n    this._tick = 0;\n  }\n\n  /**\n   * Start observing the position of the specified element.\n   * If the element is not currently attached to the DOM,\n   * it will NOT be added to the entries.\n   *\n   * @param target an `Element` target\n   */\n  public observe = (target: Element) => {\n    if (!isElement(target)) {\n      throw new Error(\n        `${errorString}: ${target} is not an instance of Element.`,\n      );\n    }\n\n    /* istanbul ignore else @preserve - a guard must be set */\n    if (!this._root.contains(target)) return;\n\n    // define a new entry\n    // push the entry into the queue\n    this._new(target).then((newEntry) => {\n      /* istanbul ignore else @preserve - don't allow duplicate entries */\n      if (!this.getEntry(target)) this.entries.set(target, newEntry);\n\n      /* istanbul ignore else @preserve */\n      if (!this._tick) this._tick = requestAnimationFrame(this._runCallback);\n    });\n  };\n\n  /**\n   * Stop observing the position of the specified element.\n   *\n   * @param target an `HTMLElement` target\n   */\n  public unobserve = (target: HTMLElement) => {\n    /* istanbul ignore else @preserve */\n    if (this.entries.has(target)) this.entries.delete(target);\n  };\n\n  /**\n   * Private method responsible for all the heavy duty,\n   * the observer's runtime.\n   */\n  private _runCallback = () => {\n    /* istanbul ignore if @preserve - a guard must be set */\n    if (!this.entries.size) return;\n\n    const queue = new Promise<PositionObserverEntry[]>((resolve) => {\n      const updates: PositionObserverEntry[] = [];\n      this.entries.forEach(\n        ({ target, boundingClientRect: oldBoundingBox }) => {\n          /* istanbul ignore if @preserve - a guard must be set when target has been removed */\n          if (!this._root.contains(target)) return;\n\n          this._new(target).then(({ boundingClientRect, isVisible }) => {\n            const { left, top, bottom, right } = boundingClientRect;\n\n            if (\n              oldBoundingBox.top !== top || oldBoundingBox.left !== left ||\n              oldBoundingBox.right !== right || oldBoundingBox.bottom !== bottom\n            ) {\n              const newEntry = { target, boundingClientRect, isVisible };\n              this.entries.set(target, newEntry);\n              updates.push(newEntry);\n            }\n          });\n        },\n      );\n\n      resolve(updates);\n    });\n\n    this._tick = requestAnimationFrame(async () => {\n      // execute the queue\n      const updates = await queue;\n\n      // only execute the callback if position actually changed\n      /* istanbul ignore else @preserve */\n      if (updates.length) this._callback(updates, this);\n\n      this._runCallback();\n    });\n  };\n\n  /**\n   * Calculate the target bounding box and determine\n   * the value of `isVisible`.\n   *\n   * @param target an `Element` target\n   */\n  private _new = (target: Element) => {\n    const { clientWidth, clientHeight } = this._root;\n\n    return new Promise<PositionObserverEntry>((resolve) => {\n      const intersectionObserver = new IntersectionObserver(\n        ([{ boundingClientRect }], ob) => {\n          ob.disconnect();\n          const { left, top, bottom, right, width, height } =\n            boundingClientRect;\n          const isVisible = top > 1 - height && left > 1 - width &&\n            bottom <= clientHeight + height - 1 &&\n            right <= clientWidth + width - 1;\n\n          resolve({\n            target,\n            isVisible,\n            boundingClientRect,\n          });\n        },\n      );\n\n      intersectionObserver.observe(target);\n    });\n  };\n\n  /**\n   * Find the entry for a given target.\n   *\n   * @param target an `HTMLElement` target\n   */\n  public getEntry = (target: Element) => this.entries.get(target);\n\n  /**\n   * Immediately stop observing all elements.\n   */\n  public disconnect = () => {\n    cancelAnimationFrame(this._tick);\n    this.entries.clear();\n    this._tick = 0;\n  };\n}\n"],"names":["v","t","u","e","i","Oo","errorString","PositionObserver","version","callback","options","isFunction","isElement","target","newEntry","queue","resolve","updates","oldBoundingBox","boundingClientRect","isVisible","left","top","bottom","right","clientWidth","clientHeight","ob","width","height"],"mappings":"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","x_google_ignoreList":[0]}