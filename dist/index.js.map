{"version":3,"file":"index.js","sources":["../node_modules/.pnpm/@thednp+shorty@2.0.7/node_modules/@thednp/shorty/dist/shorty.mjs","../src/index.ts"],"sourcesContent":["const ariaChecked = \"aria-checked\", ariaDescription = \"aria-description\", ariaDescribedBy = \"aria-describedby\", ariaExpanded = \"aria-expanded\", ariaHasPopup = \"aria-haspopup\", ariaHidden = \"aria-hidden\", ariaLabel = \"aria-label\", ariaLabelledBy = \"aria-labelledby\", ariaModal = \"aria-modal\", ariaPressed = \"aria-pressed\", ariaSelected = \"aria-selected\", ariaValueMin = \"aria-valuemin\", ariaValueMax = \"aria-valuemax\", ariaValueNow = \"aria-valuenow\", ariaValueText = \"aria-valuetext\", abortEvent = \"abort\", beforeunloadEvent = \"beforeunload\", blurEvent = \"blur\", changeEvent = \"change\", contextmenuEvent = \"contextmenu\", DOMContentLoadedEvent = \"DOMContentLoaded\", DOMMouseScrollEvent = \"DOMMouseScroll\", errorEvent = \"error\", focusEvent = \"focus\", focusinEvent = \"focusin\", focusoutEvent = \"focusout\", gesturechangeEvent = \"gesturechange\", gestureendEvent = \"gestureend\", gesturestartEvent = \"gesturestart\", keydownEvent = \"keydown\", keypressEvent = \"keypress\", keyupEvent = \"keyup\", loadEvent = \"load\", mouseclickEvent = \"click\", mousedblclickEvent = \"dblclick\", mousedownEvent = \"mousedown\", mouseupEvent = \"mouseup\", mousehoverEvent = \"hover\", mouseenterEvent = \"mouseenter\", mouseleaveEvent = \"mouseleave\", mouseinEvent = \"mousein\", mouseoutEvent = \"mouseout\", mouseoverEvent = \"mouseover\", mousemoveEvent = \"mousemove\", mousewheelEvent = \"mousewheel\", moveEvent = \"move\", orientationchangeEvent = \"orientationchange\", pointercancelEvent = \"pointercancel\", pointerdownEvent = \"pointerdown\", pointerleaveEvent = \"pointerleave\", pointermoveEvent = \"pointermove\", pointerupEvent = \"pointerup\", readystatechangeEvent = \"readystatechange\", resetEvent = \"reset\", resizeEvent = \"resize\", selectEvent = \"select\", selectendEvent = \"selectend\", selectstartEvent = \"selectstart\", scrollEvent = \"scroll\", submitEvent = \"submit\", touchstartEvent = \"touchstart\", touchmoveEvent = \"touchmove\", touchcancelEvent = \"touchcancel\", touchendEvent = \"touchend\", unloadEvent = \"unload\", nativeEvents = {\n  DOMContentLoaded: DOMContentLoadedEvent,\n  DOMMouseScroll: DOMMouseScrollEvent,\n  abort: abortEvent,\n  beforeunload: beforeunloadEvent,\n  blur: blurEvent,\n  change: changeEvent,\n  click: mouseclickEvent,\n  contextmenu: contextmenuEvent,\n  dblclick: mousedblclickEvent,\n  error: errorEvent,\n  focus: focusEvent,\n  focusin: focusinEvent,\n  focusout: focusoutEvent,\n  gesturechange: gesturechangeEvent,\n  gestureend: gestureendEvent,\n  gesturestart: gesturestartEvent,\n  hover: mousehoverEvent,\n  keydown: keydownEvent,\n  keypress: keypressEvent,\n  keyup: keyupEvent,\n  load: loadEvent,\n  mousedown: mousedownEvent,\n  mousemove: mousemoveEvent,\n  mousein: mouseinEvent,\n  mouseout: mouseoutEvent,\n  mouseenter: mouseenterEvent,\n  mouseleave: mouseleaveEvent,\n  mouseover: mouseoverEvent,\n  mouseup: mouseupEvent,\n  mousewheel: mousewheelEvent,\n  move: moveEvent,\n  orientationchange: orientationchangeEvent,\n  pointercancel: pointercancelEvent,\n  pointerdown: pointerdownEvent,\n  pointerleave: pointerleaveEvent,\n  pointermove: pointermoveEvent,\n  pointerup: pointerupEvent,\n  readystatechange: readystatechangeEvent,\n  reset: resetEvent,\n  resize: resizeEvent,\n  scroll: scrollEvent,\n  select: selectEvent,\n  selectend: selectendEvent,\n  selectstart: selectstartEvent,\n  submit: submitEvent,\n  touchcancel: touchcancelEvent,\n  touchend: touchendEvent,\n  touchmove: touchmoveEvent,\n  touchstart: touchstartEvent,\n  unload: unloadEvent\n}, dragEvent = \"drag\", dragstartEvent = \"dragstart\", dragenterEvent = \"dragenter\", dragleaveEvent = \"dragleave\", dragoverEvent = \"dragover\", dragendEvent = \"dragend\", loadstartEvent = \"loadstart\", mouseSwipeEvents = {\n  start: \"mousedown\",\n  end: \"mouseup\",\n  move: \"mousemove\",\n  cancel: \"mouseleave\"\n}, mouseClickEvents = { down: \"mousedown\", up: \"mouseup\" }, mouseHoverEvents = \"onmouseleave\" in document ? [\"mouseenter\", \"mouseleave\"] : (\n  /* istanbul ignore next @preserve */\n  [\"mouseover\", \"mouseout\"]\n), touchEvents = {\n  start: \"touchstart\",\n  end: \"touchend\",\n  move: \"touchmove\",\n  cancel: \"touchcancel\"\n}, focusEvents = { in: \"focusin\", out: \"focusout\" }, focusableSelector = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"]', keyboardEventKeys = {\n  Backspace: \"Backspace\",\n  //  8\n  Tab: \"Tab\",\n  //  9\n  Enter: \"Enter\",\n  // 13\n  Shift: \"Shift\",\n  // 16\n  Control: \"Control\",\n  // 17\n  Alt: \"Alt\",\n  // 18\n  Pause: \"Pause\",\n  // 19\n  CapsLock: \"CapsLock\",\n  // 20\n  Escape: \"Escape\",\n  // 27\n  Scape: \"Space\",\n  // 32\n  ArrowLeft: \"ArrowLeft\",\n  // 37\n  ArrowUp: \"ArrowUp\",\n  // 38\n  ArrowRight: \"ArrowRight\",\n  // 39\n  ArrowDown: \"ArrowDown\",\n  // 40\n  Insert: \"Insert\",\n  // 45\n  Delete: \"Delete\",\n  // 46\n  Meta: \"Meta\",\n  // 91 windows key\n  ContextMenu: \"ContextMenu\",\n  // 93\n  ScrollLock: \"ScrollLock\"\n  // 145\n}, keyAlt = \"Alt\", keyArrowDown = \"ArrowDown\", keyArrowUp = \"ArrowUp\", keyArrowLeft = \"ArrowLeft\", keyArrowRight = \"ArrowRight\", keyBackspace = \"Backspace\", keyCapsLock = \"CapsLock\", keyControl = \"Control\", keyDelete = \"Delete\", keyEnter = \"Enter\", keyNumpadEnter = \"NumpadEnter\", keyEscape = \"Escape\", keyInsert = \"Insert\", keyMeta = \"Meta\", keyPause = \"Pause\", keyScrollLock = \"ScrollLock\", keyShift = \"Shift\", keySpace = \"Space\", keyTab = \"Tab\", animationDuration = \"animationDuration\", animationDelay = \"animationDelay\", animationName = \"animationName\", animationEndEvent = \"animationend\", transitionDuration = \"transitionDuration\", transitionDelay = \"transitionDelay\", transitionEndEvent = \"transitionend\", transitionProperty = \"transitionProperty\", addEventListener = \"addEventListener\", removeEventListener = \"removeEventListener\", bezierEasings = {\n  linear: \"linear\",\n  easingSinusoidalIn: \"cubic-bezier(0.47,0,0.745,0.715)\",\n  easingSinusoidalOut: \"cubic-bezier(0.39,0.575,0.565,1)\",\n  easingSinusoidalInOut: \"cubic-bezier(0.445,0.05,0.55,0.95)\",\n  easingQuadraticIn: \"cubic-bezier(0.550,0.085,0.680,0.530)\",\n  easingQuadraticOut: \"cubic-bezier(0.250,0.460,0.450,0.940)\",\n  easingQuadraticInOut: \"cubic-bezier(0.455,0.030,0.515,0.955)\",\n  easingCubicIn: \"cubic-bezier(0.55,0.055,0.675,0.19)\",\n  easingCubicOut: \"cubic-bezier(0.215,0.61,0.355,1)\",\n  easingCubicInOut: \"cubic-bezier(0.645,0.045,0.355,1)\",\n  easingQuarticIn: \"cubic-bezier(0.895,0.03,0.685,0.22)\",\n  easingQuarticOut: \"cubic-bezier(0.165,0.84,0.44,1)\",\n  easingQuarticInOut: \"cubic-bezier(0.77,0,0.175,1)\",\n  easingQuinticIn: \"cubic-bezier(0.755,0.05,0.855,0.06)\",\n  easingQuinticOut: \"cubic-bezier(0.23,1,0.32,1)\",\n  easingQuinticInOut: \"cubic-bezier(0.86,0,0.07,1)\",\n  easingExponentialIn: \"cubic-bezier(0.95,0.05,0.795,0.035)\",\n  easingExponentialOut: \"cubic-bezier(0.19,1,0.22,1)\",\n  easingExponentialInOut: \"cubic-bezier(1,0,0,1)\",\n  easingCircularIn: \"cubic-bezier(0.6,0.04,0.98,0.335)\",\n  easingCircularOut: \"cubic-bezier(0.075,0.82,0.165,1)\",\n  easingCircularInOut: \"cubic-bezier(0.785,0.135,0.15,0.86)\",\n  easingBackIn: \"cubic-bezier(0.6,-0.28,0.735,0.045)\",\n  easingBackOut: \"cubic-bezier(0.175,0.885,0.32,1.275)\",\n  easingBackInOut: \"cubic-bezier(0.68,-0.55,0.265,1.55)\"\n}, offsetHeight = \"offsetHeight\", offsetWidth = \"offsetWidth\", scrollHeight = \"scrollHeight\", scrollWidth = \"scrollWidth\", tabindex = \"tabindex\", userAgentData = navigator.userAgentData, { userAgent: userAgentString } = navigator, userAgent = userAgentString, isMobile = () => {\n  const mobileBrands = /iPhone|iPad|iPod|Android/i;\n  return navigator?.userAgentData?.brands.some(\n    (x) => mobileBrands.test(x.brand)\n  ) || mobileBrands.test(navigator?.userAgent) || !1;\n}, isApple = () => {\n  const appleBrands = /(iPhone|iPod|iPad)/;\n  return navigator?.userAgentData?.brands.some(\n    (x) => appleBrands.test(x.brand)\n  ) || /* istanbul ignore next @preserve */\n  appleBrands.test(\n    navigator?.userAgent\n  ) || !1;\n}, isFirefox = () => navigator?.userAgent?.includes(\"Firefox\") || /* istanbul ignore next @preserve */\n!1, support3DTransform = () => [\"webkitPerspective\", \"perspective\"].some((p) => p in document.head.style), noop = () => {\n}, on = (element, eventName, listener, options) => {\n  const ops = options || !1;\n  element.addEventListener(\n    eventName,\n    listener,\n    ops\n  );\n}, off = (element, eventName, listener, options) => {\n  const ops = options || !1;\n  element.removeEventListener(\n    eventName,\n    listener,\n    ops\n  );\n}, one = (element, eventName, listener, options) => {\n  const handlerWrapper = (e) => {\n    (e.target === element || e.currentTarget === element) && (listener.apply(element, [e]), off(element, eventName, handlerWrapper, options));\n  };\n  on(element, eventName, handlerWrapper, options);\n}, supportPassive = () => {\n  let result = !1;\n  try {\n    const opts = Object.defineProperty({}, \"passive\", {\n      get: () => (result = !0, result)\n    });\n    one(document, DOMContentLoadedEvent, noop, opts);\n  } catch {\n  }\n  return result;\n}, supportTransform = () => [\"webkitTransform\", \"transform\"].some((p) => p in document.head.style), supportTouch = () => \"ontouchstart\" in window || /* istanbul ignore next @preserve */\n\"msMaxTouchPoints\" in navigator, supportAnimation = () => [\"webkitAnimation\", \"animation\"].some((p) => p in document.head.style), supportTransition = () => [\"webkitTransition\", \"transition\"].some((p) => p in document.head.style), getAttribute = (element, att) => element.getAttribute(att), getAttributeNS = (ns, element, att) => element.getAttributeNS(ns, att), hasAttribute = (element, att) => element.hasAttribute(att), hasAttributeNS = (ns, element, att) => element.hasAttributeNS(ns, att), setAttribute = (element, att, value) => element.setAttribute(att, value), setAttributeNS = (ns, element, att, value) => element.setAttributeNS(ns, att, value), removeAttribute = (element, att) => element.removeAttribute(att), removeAttributeNS = (ns, element, att) => element.removeAttributeNS(ns, att), addClass = (element, ...classNAME) => {\n  element.classList.add(...classNAME);\n}, removeClass = (element, ...classNAME) => {\n  element.classList.remove(...classNAME);\n}, hasClass = (element, classNAME) => element.classList.contains(classNAME), { body: documentBody } = document, { documentElement } = document, { head: documentHead } = document, ArrayFrom = (arr) => Array.from(arr), isObject = (obj) => obj != null && typeof obj == \"object\" || !1, isNode = (node) => isObject(node) && typeof node.nodeType == \"number\" && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].some(\n  (x) => node.nodeType === x\n) || !1, isHTMLElement = (element) => isNode(element) && element.nodeType === 1 || !1, componentData = /* @__PURE__ */ new Map(), Data = {\n  data: componentData,\n  /**\n   * Sets web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @param instance the component instance\n   */\n  set: (element, component, instance) => {\n    if (!isHTMLElement(element)) return;\n    componentData.has(component) || componentData.set(component, /* @__PURE__ */ new Map()), componentData.get(component).set(element, instance);\n  },\n  /**\n   * Returns all instances for specified component.\n   *\n   * @param component the component's name or a unique key\n   * @returns all the component instances\n   */\n  getAllFor: (component) => componentData.get(component) || null,\n  /**\n   * Returns the instance associated with the target.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @returns the instance\n   */\n  get: (element, component) => {\n    if (!isHTMLElement(element) || !component) return null;\n    const instanceMap = Data.getAllFor(component);\n    return element && instanceMap && instanceMap.get(element) || null;\n  },\n  /**\n   * Removes web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   */\n  remove: (element, component) => {\n    const instanceMap = Data.getAllFor(component);\n    !instanceMap || !isHTMLElement(element) || (instanceMap.delete(element), instanceMap.size === 0 && componentData.delete(component));\n  }\n}, getInstance = (target, component) => Data.get(target, component), isString = (str) => typeof str == \"string\" || !1, isWindow = (obj) => isObject(obj) && obj.constructor.name === \"Window\" || !1, isDocument = (obj) => isNode(obj) && obj.nodeType === 9 || !1, getDocument = (node) => isWindow(node) ? node.document : isDocument(node) ? node : isNode(node) ? node.ownerDocument : globalThis.document, ObjectAssign = (obj, ...source) => Object.assign(obj, ...source), createElement = (param) => {\n  if (!param) return;\n  if (isString(param))\n    return getDocument().createElement(param);\n  const { tagName } = param, newElement = createElement(tagName);\n  if (!newElement) return;\n  const attr = { ...param };\n  return delete attr.tagName, ObjectAssign(newElement, attr);\n}, createElementNS = (ns, param) => {\n  if (!ns || !param) return;\n  if (isString(param))\n    return getDocument().createElementNS(ns, param);\n  const { tagName } = param, newElement = createElementNS(ns, tagName);\n  if (!newElement) return;\n  const attr = { ...param };\n  return delete attr.tagName, ObjectAssign(newElement, attr);\n}, dispatchEvent = (element, event) => element.dispatchEvent(event), distinct = (value, index, arr) => arr.indexOf(value) === index, getElementStyle = (element, property) => {\n  const computedStyle = getComputedStyle(element), prop = property.replace(\"webkit\", \"Webkit\").replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  return computedStyle.getPropertyValue(prop);\n}, getElementAnimationDelay = (element) => {\n  const propertyValue = getElementStyle(element, animationName), durationValue = getElementStyle(element, animationDelay), durationScale = durationValue.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, duration = propertyValue && propertyValue !== \"none\" ? parseFloat(durationValue) * durationScale : 0;\n  return Number.isNaN(duration) ? (\n    /* istanbul ignore next */\n    0\n  ) : duration;\n}, getElementAnimationDuration = (element) => {\n  const propertyValue = getElementStyle(element, animationName), durationValue = getElementStyle(element, animationDuration), durationScale = durationValue.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, duration = propertyValue && propertyValue !== \"none\" ? parseFloat(durationValue) * durationScale : 0;\n  return Number.isNaN(duration) ? (\n    /* istanbul ignore next */\n    0\n  ) : duration;\n}, emulateAnimationEnd = (element, handler) => {\n  let called = 0;\n  const endEvent = new Event(animationEndEvent), duration = getElementAnimationDuration(element), delay = getElementAnimationDelay(element);\n  if (duration) {\n    const animationEndWrapper = (e) => {\n      e.target === element && (handler.apply(element, [e]), element.removeEventListener(animationEndEvent, animationEndWrapper), called = 1);\n    };\n    element.addEventListener(animationEndEvent, animationEndWrapper), setTimeout(() => {\n      called || dispatchEvent(element, endEvent);\n    }, duration + delay + 17);\n  } else\n    handler.apply(element, [endEvent]);\n}, getElementTransitionDelay = (element) => {\n  const propertyValue = getElementStyle(element, transitionProperty), delayValue = getElementStyle(element, transitionDelay), delayScale = delayValue.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, duration = propertyValue && propertyValue !== \"none\" ? parseFloat(delayValue) * delayScale : (\n    /* istanbul ignore next */\n    0\n  );\n  return Number.isNaN(duration) ? (\n    /* istanbul ignore next */\n    0\n  ) : duration;\n}, getElementTransitionDuration = (element) => {\n  const propertyValue = getElementStyle(element, transitionProperty), durationValue = getElementStyle(element, transitionDuration), durationScale = durationValue.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, duration = propertyValue && propertyValue !== \"none\" ? parseFloat(durationValue) * durationScale : (\n    /* istanbul ignore next */\n    0\n  );\n  return Number.isNaN(duration) ? (\n    /* istanbul ignore next */\n    0\n  ) : duration;\n}, emulateTransitionEnd = (element, handler) => {\n  let called = 0;\n  const endEvent = new Event(transitionEndEvent), duration = getElementTransitionDuration(element), delay = getElementTransitionDelay(element);\n  if (duration) {\n    const transitionEndWrapper = (e) => {\n      e.target === element && (handler.apply(element, [e]), element.removeEventListener(transitionEndEvent, transitionEndWrapper), called = 1);\n    };\n    element.addEventListener(transitionEndEvent, transitionEndWrapper), setTimeout(() => {\n      called || dispatchEvent(element, endEvent);\n    }, duration + delay + 17);\n  } else\n    handler.apply(element, [endEvent]);\n}, Float32ArrayFrom = (arr) => Float32Array.from(Array.from(arr)), Float64ArrayFrom = (arr) => Float64Array.from(Array.from(arr)), focus = (element, options) => element.focus(options), normalizeValue = (value) => [\"true\", !0].includes(value) ? !0 : [\"false\", !1].includes(value) ? !1 : [\"null\", \"\", null, void 0].includes(value) ? null : value !== \"\" && !Number.isNaN(+value) ? +value : value, ObjectEntries = (obj) => Object.entries(obj), toLowerCase = (source) => source.toLowerCase(), normalizeOptions = (element, defaultOps, inputOps, ns) => {\n  const INPUT = { ...inputOps }, data = { ...element.dataset }, normalOps = { ...defaultOps }, dataOps = {}, title = \"title\";\n  return ObjectEntries(data).forEach(([k, v]) => {\n    const key = ns && typeof k == \"string\" && k.includes(ns) ? k.replace(ns, \"\").replace(\n      /[A-Z]/g,\n      (match) => toLowerCase(match)\n    ) : (\n      /* istanbul ignore next @preserve */\n      k\n    );\n    dataOps[key] = normalizeValue(v);\n  }), ObjectEntries(INPUT).forEach(([k, v]) => {\n    INPUT[k] = normalizeValue(v);\n  }), ObjectEntries(defaultOps).forEach(([k, v]) => {\n    k in INPUT ? normalOps[k] = INPUT[k] : k in dataOps ? normalOps[k] = dataOps[k] : normalOps[k] = k === title ? getAttribute(element, title) : v;\n  }), normalOps;\n}, ObjectHasOwn = (obj, prop) => isObject(obj) && (Object.hasOwn(obj, prop) || prop in obj), ObjectKeys = (obj) => Object.keys(obj), ObjectValues = (obj) => Object.values(obj), ObjectFromEntries = (entries) => Object.fromEntries(entries), createCustomEvent = (eventType, config) => {\n  const OriginalCustomEvent = new CustomEvent(eventType, {\n    cancelable: !0,\n    bubbles: !0\n  });\n  return isObject(config) && ObjectAssign(OriginalCustomEvent, config), OriginalCustomEvent;\n}, passiveHandler = { passive: !0 }, reflow = (element) => element.offsetHeight, setElementStyle = (element, styles) => {\n  ObjectEntries(styles).forEach(([key, value]) => {\n    if (value && isString(key) && key.includes(\"--\"))\n      element.style.setProperty(key, value);\n    else {\n      const propObject = {};\n      propObject[key] = value, ObjectAssign(element.style, propObject);\n    }\n  });\n}, isMap = (obj) => isObject(obj) && obj.constructor.name === \"Map\" || !1, isNumber = (num) => typeof num == \"number\" || !1, TimeCache = /* @__PURE__ */ new Map(), Timer = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   *\n   * @param element target element\n   * @param callback the callback\n   * @param delay the execution delay\n   * @param key a unique key\n   */\n  set: (element, callback, delay, key) => {\n    isHTMLElement(element) && (key && key.length ? (TimeCache.has(element) || TimeCache.set(element, /* @__PURE__ */ new Map()), TimeCache.get(element).set(key, setTimeout(callback, delay))) : TimeCache.set(element, setTimeout(callback, delay)));\n  },\n  /**\n   * Returns the timer associated with the target.\n   *\n   * @param element target element\n   * @param key a unique\n   * @returns the timer\n   */\n  get: (element, key) => {\n    if (!isHTMLElement(element)) return null;\n    const keyTimers = TimeCache.get(element);\n    return key && keyTimers && isMap(keyTimers) ? keyTimers.get(key) || /* istanbul ignore next @preserve */\n    null : isNumber(keyTimers) ? keyTimers : null;\n  },\n  /**\n   * Clears the element's timer.\n   *\n   * @param element target element\n   * @param key a unique key\n   */\n  clear: (element, key) => {\n    if (!isHTMLElement(element)) return;\n    const keyTimers = TimeCache.get(element);\n    key && key.length && isMap(keyTimers) ? (clearTimeout(keyTimers.get(key)), keyTimers.delete(key), keyTimers.size === 0 && TimeCache.delete(element)) : (clearTimeout(keyTimers), TimeCache.delete(element));\n  }\n}, toUpperCase = (source) => source.toUpperCase(), querySelectorAll = (selector, parent) => (isNode(parent) ? parent : getDocument()).querySelectorAll(selector), focusTrapMap = /* @__PURE__ */ new Map();\nfunction handleKeyboardNavigation(event) {\n  const { shiftKey, code } = event, doc = getDocument(this), focusableElements = [\n    ...querySelectorAll(focusableSelector, this)\n  ].filter(\n    (el) => !hasAttribute(el, \"disabled\") && !getAttribute(el, ariaHidden)\n  );\n  if (!focusableElements.length) return;\n  const firstFocusable = focusableElements[0], lastFocusable = focusableElements[focusableElements.length - 1];\n  code === \"Tab\" && (shiftKey && doc.activeElement === firstFocusable ? (lastFocusable.focus(), event.preventDefault()) : !shiftKey && doc.activeElement === lastFocusable && (firstFocusable.focus(), event.preventDefault()));\n}\nconst hasFocusTrap = (target) => focusTrapMap.has(target) === !0, toggleFocusTrap = (target) => {\n  const isCurrentlyTrapped = hasFocusTrap(target);\n  (isCurrentlyTrapped ? off : on)(target, \"keydown\", handleKeyboardNavigation), isCurrentlyTrapped ? focusTrapMap.delete(target) : focusTrapMap.set(target, !0);\n}, getBoundingClientRect = (element, includeScale) => {\n  const { width, height, top, right, bottom, left } = element.getBoundingClientRect();\n  let scaleX = 1, scaleY = 1;\n  if (includeScale && isHTMLElement(element)) {\n    const { offsetWidth: offsetWidth2, offsetHeight: offsetHeight2 } = element;\n    scaleX = offsetWidth2 > 0 ? Math.round(width) / offsetWidth2 : (\n      /* istanbul ignore next @preserve */\n      1\n    ), scaleY = offsetHeight2 > 0 ? Math.round(height) / offsetHeight2 : (\n      /* istanbul ignore next @preserve */\n      1\n    );\n  }\n  return {\n    width: width / scaleX,\n    height: height / scaleY,\n    top: top / scaleY,\n    right: right / scaleX,\n    bottom: bottom / scaleY,\n    left: left / scaleX,\n    x: left / scaleX,\n    y: top / scaleY\n  };\n}, getDocumentBody = (node) => getDocument(node).body, getDocumentElement = (node) => getDocument(node).documentElement, getDocumentHead = (node) => getDocument(node).head, getNodeScroll = (element) => {\n  const isWin = isWindow(element), x = isWin ? element.scrollX : element.scrollLeft, y = isWin ? element.scrollY : element.scrollTop;\n  return { x, y };\n}, isShadowRoot = (element) => isNode(element) && element.constructor.name === \"ShadowRoot\" || !1, getParentNode = (node) => node.nodeName === \"HTML\" ? node : isHTMLElement(node) && node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\nisNode(node) && node.parentNode || // DOM Element detected\nisShadowRoot(node) && node.host || // ShadowRoot detected\ngetDocumentElement(node), isScaledElement = (element) => {\n  if (!isHTMLElement(element)) return !1;\n  const { width, height } = getBoundingClientRect(element), { offsetWidth: offsetWidth2, offsetHeight: offsetHeight2 } = element;\n  return Math.round(width) !== offsetWidth2 || Math.round(height) !== offsetHeight2;\n}, getRectRelativeToOffsetParent = (element, offsetParent, scroll) => {\n  const isParentAnElement = isHTMLElement(offsetParent), rect = getBoundingClientRect(\n    element,\n    isParentAnElement && isScaledElement(offsetParent)\n  ), offsets = { x: 0, y: 0 };\n  if (isParentAnElement) {\n    const offsetRect = getBoundingClientRect(offsetParent, !0);\n    offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;\n  }\n  return {\n    x: rect.left + scroll.x - offsets.x,\n    y: rect.top + scroll.y - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n};\nlet elementUID = 0, elementMapUID = 0;\nconst elementIDMap = /* @__PURE__ */ new Map(), getUID = (element, key) => {\n  let result = key ? elementUID : elementMapUID;\n  if (key) {\n    const elID = getUID(element), elMap = elementIDMap.get(elID) || /* @__PURE__ */ new Map();\n    elementIDMap.has(elID) || elementIDMap.set(elID, elMap), isMap(elMap) && !elMap.has(key) ? (elMap.set(key, result), elementUID += 1) : result = elMap.get(key);\n  } else {\n    const elkey = element.id || element;\n    elementIDMap.has(elkey) ? result = elementIDMap.get(elkey) : (elementIDMap.set(elkey, result), elementMapUID += 1);\n  }\n  return result;\n}, getWindow = (node) => node ? isDocument(node) ? node.defaultView : isNode(node) ? node?.ownerDocument?.defaultView : node : window, isArray = (obj) => Array.isArray(obj) || !1, isCanvas = (element) => isNode(element) && element.nodeName === \"CANVAS\" || !1, isCustomElement = (element) => isHTMLElement(element) && !!element.shadowRoot || !1, isElement = (element) => isNode(element) && [1, 2, 3, 4, 5, 6, 7, 8].some((x) => element.nodeType === x) || !1, isElementInScrollRange = (element) => {\n  if (!isNode(element)) return !1;\n  const { top, bottom } = getBoundingClientRect(element), { clientHeight } = getDocumentElement(element);\n  return top <= clientHeight && bottom >= 0;\n}, isElementInViewport = (element) => {\n  if (!isNode(element)) return !1;\n  const { clientWidth, clientHeight } = getDocumentElement(element), { top, left, bottom, right } = getBoundingClientRect(element, !0);\n  return top >= 0 && left >= 0 && bottom <= clientHeight && right <= clientWidth;\n}, isElementsArray = (obj) => isArray(obj) && obj.every(isHTMLElement) || !1, isFunction = (fn) => typeof fn == \"function\" || !1, isHTMLCollection = (obj) => isObject(obj) && obj.constructor.name === \"HTMLCollection\" || !1, isHTMLImageElement = (element) => isHTMLElement(element) && element.tagName === \"IMG\" || !1, isJSON = (str) => {\n  if (!isString(str)) return !1;\n  try {\n    JSON.parse(str);\n  } catch {\n    return !1;\n  }\n  return !0;\n}, isWeakMap = (obj) => isObject(obj) && obj.constructor.name === \"WeakMap\" || !1, isMedia = (element) => isNode(element) && [\"SVG\", \"Image\", \"Video\", \"Canvas\"].some(\n  (s) => element.constructor.name.includes(s)\n) || !1, isNodeList = (obj) => isObject(obj) && obj.constructor.name === \"NodeList\" || !1, isRTL = (node) => getDocumentElement(node).dir === \"rtl\", isSVGElement = (element) => isNode(element) && element.constructor.name.includes(\"SVG\") || !1, isTableElement = (element) => isNode(element) && [\"TABLE\", \"TD\", \"TH\"].includes(element.nodeName) || !1, closest = (element, selector) => element ? element.closest(selector) || // break out of `ShadowRoot`\nclosest(element.getRootNode().host, selector) : null, querySelector = (selector, parent) => isHTMLElement(selector) ? selector : (isNode(parent) ? parent : getDocument()).querySelector(selector), getElementsByTagName = (selector, parent) => (isNode(parent) ? parent : getDocument()).getElementsByTagName(\n  selector\n), getCustomElements = (parent) => [...getElementsByTagName(\"*\", parent)].filter(isCustomElement), getElementById = (id, context) => getDocument(context).getElementById(id) || null, getElementsByClassName = (selector, parent) => (parent && isNode(parent) ? parent : getDocument()).getElementsByClassName(\n  selector\n), matches = (target, selector) => target.matches(selector), version = \"2.0.7\";\nexport {\n  ArrayFrom,\n  DOMContentLoadedEvent,\n  DOMMouseScrollEvent,\n  Data,\n  Float32ArrayFrom,\n  Float64ArrayFrom,\n  ObjectAssign,\n  ObjectEntries,\n  ObjectFromEntries,\n  ObjectHasOwn,\n  ObjectKeys,\n  ObjectValues,\n  Timer,\n  abortEvent,\n  addClass,\n  addEventListener,\n  animationDelay,\n  animationDuration,\n  animationEndEvent,\n  animationName,\n  ariaChecked,\n  ariaDescribedBy,\n  ariaDescription,\n  ariaExpanded,\n  ariaHasPopup,\n  ariaHidden,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaModal,\n  ariaPressed,\n  ariaSelected,\n  ariaValueMax,\n  ariaValueMin,\n  ariaValueNow,\n  ariaValueText,\n  beforeunloadEvent,\n  bezierEasings,\n  blurEvent,\n  changeEvent,\n  closest,\n  contextmenuEvent,\n  createCustomEvent,\n  createElement,\n  createElementNS,\n  dispatchEvent,\n  distinct,\n  documentBody,\n  documentElement,\n  documentHead,\n  dragEvent,\n  dragendEvent,\n  dragenterEvent,\n  dragleaveEvent,\n  dragoverEvent,\n  dragstartEvent,\n  emulateAnimationEnd,\n  emulateTransitionEnd,\n  errorEvent,\n  focus,\n  focusEvent,\n  focusEvents,\n  focusableSelector,\n  focusinEvent,\n  focusoutEvent,\n  gesturechangeEvent,\n  gestureendEvent,\n  gesturestartEvent,\n  getAttribute,\n  getAttributeNS,\n  getBoundingClientRect,\n  getCustomElements,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getDocumentHead,\n  getElementAnimationDelay,\n  getElementAnimationDuration,\n  getElementById,\n  getElementStyle,\n  getElementTransitionDelay,\n  getElementTransitionDuration,\n  getElementsByClassName,\n  getElementsByTagName,\n  getInstance,\n  getNodeScroll,\n  getParentNode,\n  getRectRelativeToOffsetParent,\n  getUID,\n  getWindow,\n  hasAttribute,\n  hasAttributeNS,\n  hasClass,\n  hasFocusTrap,\n  isApple,\n  isArray,\n  isCanvas,\n  isCustomElement,\n  isDocument,\n  isElement,\n  isElementInScrollRange,\n  isElementInViewport,\n  isElementsArray,\n  isFirefox,\n  isFunction,\n  isHTMLCollection,\n  isHTMLElement,\n  isHTMLImageElement,\n  isJSON,\n  isMap,\n  isMedia,\n  isMobile,\n  isNode,\n  isNodeList,\n  isNumber,\n  isObject,\n  isRTL,\n  isSVGElement,\n  isScaledElement,\n  isShadowRoot,\n  isString,\n  isTableElement,\n  isWeakMap,\n  isWindow,\n  keyAlt,\n  keyArrowDown,\n  keyArrowLeft,\n  keyArrowRight,\n  keyArrowUp,\n  keyBackspace,\n  keyCapsLock,\n  keyControl,\n  keyDelete,\n  keyEnter,\n  keyEscape,\n  keyInsert,\n  keyMeta,\n  keyNumpadEnter,\n  keyPause,\n  keyScrollLock,\n  keyShift,\n  keySpace,\n  keyTab,\n  keyboardEventKeys,\n  keydownEvent,\n  keypressEvent,\n  keyupEvent,\n  loadEvent,\n  loadstartEvent,\n  matches,\n  mouseClickEvents,\n  mouseHoverEvents,\n  mouseSwipeEvents,\n  mouseclickEvent,\n  mousedblclickEvent,\n  mousedownEvent,\n  mouseenterEvent,\n  mousehoverEvent,\n  mouseinEvent,\n  mouseleaveEvent,\n  mousemoveEvent,\n  mouseoutEvent,\n  mouseoverEvent,\n  mouseupEvent,\n  mousewheelEvent,\n  moveEvent,\n  nativeEvents,\n  noop,\n  normalizeOptions,\n  normalizeValue,\n  off,\n  offsetHeight,\n  offsetWidth,\n  on,\n  one,\n  orientationchangeEvent,\n  passiveHandler,\n  pointercancelEvent,\n  pointerdownEvent,\n  pointerleaveEvent,\n  pointermoveEvent,\n  pointerupEvent,\n  querySelector,\n  querySelectorAll,\n  readystatechangeEvent,\n  reflow,\n  removeAttribute,\n  removeAttributeNS,\n  removeClass,\n  removeEventListener,\n  resetEvent,\n  resizeEvent,\n  scrollEvent,\n  scrollHeight,\n  scrollWidth,\n  selectEvent,\n  selectendEvent,\n  selectstartEvent,\n  setAttribute,\n  setAttributeNS,\n  setElementStyle,\n  submitEvent,\n  support3DTransform,\n  supportAnimation,\n  supportPassive,\n  supportTouch,\n  supportTransform,\n  supportTransition,\n  tabindex,\n  toLowerCase,\n  toUpperCase,\n  toggleFocusTrap,\n  touchEvents,\n  touchcancelEvent,\n  touchendEvent,\n  touchmoveEvent,\n  touchstartEvent,\n  transitionDelay,\n  transitionDuration,\n  transitionEndEvent,\n  transitionProperty,\n  unloadEvent,\n  userAgent,\n  userAgentData,\n  version\n};\n//# sourceMappingURL=shorty.mjs.map\n","import { isFunction, isHTMLElement } from \"@thednp/shorty\";\nimport { version } from \"../package.json\";\n\nexport type PositionObserverCallback = (\n  entries: PositionObserverEntry[],\n  observer: PositionObserver,\n) => void;\n\nexport type PositionObserverEntry = {\n  target: HTMLElement;\n  boundingClientRect: DOMRect;\n  isVisible: boolean;\n};\n\nexport type PositionObserverOptions = {\n  root: HTMLElement;\n};\n\nconst errorString = \"PositionObserver Error\";\n\n/**\n * The PositionObserver class is a utility class that observes the position\n * of DOM elements and triggers a callback when their position changes.\n */\nexport default class PositionObserver {\n  public entries: Map<HTMLElement, PositionObserverEntry>;\n  public static version = version;\n  private _tick: number;\n  private _root: HTMLElement;\n  private _callback: PositionObserverCallback;\n\n  /**\n   * The constructor takes two arguments, a `callback`, which is called\n   * whenever the position of an observed element changes and an `options` object.\n   * The callback function should take an array of `PositionObserverEntry` objects\n   * as its only argument, but it's not required.\n   *\n   * @param callback the callback that applies to all targets of this observer\n   * @param options the options of this observer\n   */\n  constructor(\n    callback: PositionObserverCallback,\n    options?: Partial<PositionObserverOptions>,\n  ) {\n    if (!isFunction(callback)) {\n      throw new Error(`${errorString}: ${callback} is not a function.`);\n    }\n    this.entries = new Map();\n    this._callback = callback;\n    this._root = isHTMLElement(options?.root)\n      ? options.root\n      /* istanbul ignore next @preserve */\n      : document?.documentElement;\n    this._tick = 0;\n  }\n\n  /**\n   * Start observing the position of the specified element.\n   * If the element is not currently attached to the DOM,\n   * it will NOT be added to the entries.\n   *\n   * @param target an `HTMLElement` target\n   */\n  public observe = (target: HTMLElement) => {\n    if (!isHTMLElement(target)) {\n      throw new Error(\n        `${errorString}: ${target} is not an instance of HTMLElement.`,\n      );\n    }\n\n    /* istanbul ignore else @preserve - a guard must be set */\n    if (!this._root.contains(target)) return;\n\n    // define a new entry\n    // push the entry into the queue\n    this._new(target).then((newEntry) => {\n      /* istanbul ignore else @preserve - don't allow duplicate entries */\n      if (!this.getEntry(target)) this.entries.set(target, newEntry);\n\n      /* istanbul ignore else @preserve */\n      if (!this._tick) this._tick = requestAnimationFrame(this._runCallback);\n    });\n  };\n\n  /**\n   * Stop observing the position of the specified element.\n   *\n   * @param target an `HTMLElement` target\n   */\n  public unobserve = (target: HTMLElement) => {\n    /* istanbul ignore else @preserve */\n    if (this.entries.has(target)) this.entries.delete(target);\n  };\n\n  /**\n   * Private method responsible for all the heavy duty,\n   * the observer's runtime.\n   */\n  private _runCallback = () => {\n    /* istanbul ignore if @preserve - a guard must be set */\n    if (!this.entries.size) return;\n\n    const queue = new Promise<PositionObserverEntry[]>((resolve) => {\n      const updates: PositionObserverEntry[] = [];\n      this.entries.forEach(\n        async ({ target, boundingClientRect: oldBoundingBox }) => {\n          /* istanbul ignore if @preserve - a guard must be set when target has been removed */\n          if (!this._root.contains(target)) return;\n\n          await this._new(target).then(({ boundingClientRect, isVisible }) => {\n            const { left, top, bottom, right } = boundingClientRect;\n\n            if (\n              oldBoundingBox.top !== top || oldBoundingBox.left !== left ||\n              oldBoundingBox.right !== right || oldBoundingBox.bottom !== bottom\n            ) {\n              const newEntry = { target, boundingClientRect, isVisible };\n              this.entries.set(target, newEntry);\n              updates.push(newEntry);\n            }\n          });\n        },\n      );\n\n      resolve(updates);\n    });\n\n    this._tick = requestAnimationFrame(async () => {\n      const updates = await queue;\n\n      // only execute the callback if position actually changed\n      /* istanbul ignore else @preserve */\n      if (updates.length) this._callback(updates, this);\n\n      this._runCallback();\n    });\n  };\n\n  /**\n   * Calculate the target bounding box and determine\n   * the value of `isVisible`.\n   *\n   * @param target an `HTMLElement` target\n   */\n  private _new = (target: HTMLElement) => {\n    const { clientWidth, clientHeight } = this._root;\n\n    return new Promise<PositionObserverEntry>((resolve) => {\n      const intersectionObserver = new IntersectionObserver(\n        ([{ boundingClientRect }], ob) => {\n          ob.disconnect();\n          const { left, top, bottom, right, width, height } =\n            boundingClientRect;\n          const isVisible = top > 1 - height && left > 1 - width &&\n            bottom <= clientHeight + height - 1 &&\n            right <= clientWidth + width - 1;\n\n          resolve({\n            target,\n            isVisible,\n            boundingClientRect,\n          });\n        },\n      );\n\n      intersectionObserver.observe(target);\n    });\n  };\n\n  /**\n   * Find the entry for a given target.\n   *\n   * @param target an `HTMLElement` target\n   */\n  public getEntry = (target: HTMLElement) => this.entries.get(target);\n\n  /**\n   * Immediately stop observing all elements.\n   */\n  public disconnect = () => {\n    cancelAnimationFrame(this._tick);\n    this.entries.clear();\n    this._tick = 0;\n  };\n}\n"],"names":["isObject","obj","isNode","node","x","isHTMLElement","element","isFunction","fn","errorString","PositionObserver","version","callback","options","target","newEntry","queue","resolve","updates","oldBoundingBox","boundingClientRect","isVisible","left","top","bottom","right","clientWidth","clientHeight","ob","width","height"],"mappings":"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","x_google_ignoreList":[0]}