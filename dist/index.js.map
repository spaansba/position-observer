{"version":3,"file":"index.js","names":["callback: PositionObserverCallback","options?: Partial<PositionObserverOptions>","target: Element","updates: PositionObserverEntry[]"],"sources":["../package.json","../src/index.ts"],"sourcesContent":["{\n  \"name\": \"@thednp/position-observer\",\n  \"version\": \"1.0.11\",\n  \"author\": \"thednp\",\n  \"license\": \"MIT\",\n  \"description\": \"🏯 PositionObserver is a JavaScript tool that provides a way to asynchronously observe changes in the position of a target element within its viewport.\",\n  \"homepage\": \"https://thednp.github.io/position-observer/\",\n  \"source\": \"./src/index.ts\",\n  \"main\": \"./dist/index.js\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"scripts\": {\n    \"pre-test\": \"pnpm clean-coverage\",\n    \"dev\": \"vite --open ./demo/index.html --port 8577\",\n    \"serve\": \"vite --open ./docs/index.html --port 8577\",\n    \"test\": \"pnpm pre-test && vitest --config vitest.config.ts\",\n    \"test-ui\": \"pnpm pre-test && vitest --config vitest.config-ui.ts --browser=chrome\",\n    \"clean-coverage\": \"rm -rf coverage .nyc_output\",\n    \"badges\": \"npx -p dependency-version-badge update-badge typescript vitest vite\",\n    \"build\": \"tsdown\",\n    \"build_\": \"vite build\",\n    \"build:all\": \"pnpm build && pnpm build:docs\",\n    \"build:docs\": \"vite build demo --config demo/vite.config.ts\",\n    \"lint\": \"deno lint src && pnpm check:ts\",\n    \"format\": \"deno fmt src\",\n    \"check:ts\": \"tsc --noEmit\",\n    \"prepublishOnly\": \"pnpm update --latest && pnpm lint && pnpm format && pnpm build:all && pnpm badges\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/thednp/position-observer/issues\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\",\n    \"registry\": \"https://registry.npmjs.org/\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/thednp/position-observer.git\"\n  },\n  \"keywords\": [\n    \"position-observer\",\n    \"observer\",\n    \"intersection\",\n    \"resize\",\n    \"position\",\n    \"typescript\"\n  ],\n  \"dependencies\": {\n    \"@thednp/shorty\": \"^2.0.11\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^22.15.30\",\n    \"@vitest/browser\": \"^3.2.3\",\n    \"@vitest/coverage-istanbul\": \"^3.2.3\",\n    \"@vitest/ui\": \"^3.2.3\",\n    \"playwright\": \"^1.52.0\",\n    \"tsdown\": \"^0.12.7\",\n    \"typescript\": \"5.8.3\",\n    \"vite\": \"^6.3.5\",\n    \"vitest\": \"^3.2.3\"\n  },\n  \"packageManager\": \"pnpm@8.6.12\",\n  \"engines\": {\n    \"node\": \">=16\",\n    \"pnpm\": \">=8.6.0\"\n  }\n}\n","import { isElement, isFunction } from \"@thednp/shorty\";\nimport { version } from \"../package.json\";\n\nexport type PositionObserverCallback = (\n  entries: PositionObserverEntry[],\n  observer: PositionObserver,\n) => void;\n\nexport type PositionObserverEntry = {\n  target: Element;\n  boundingClientRect: DOMRect;\n  clientHeight: number;\n  clientWidth: number;\n};\n\nexport type PositionObserverOptions = {\n  root: HTMLElement;\n};\n\nconst errorString = \"PositionObserver Error\";\n\n/**\n * The PositionObserver class is a utility class that observes the position\n * of DOM elements and triggers a callback when their position changes.\n */\nexport default class PositionObserver {\n  public entries: Map<Element, PositionObserverEntry>;\n  public static version = version;\n  private _tick: number;\n  private _root: Element;\n  private _callback: PositionObserverCallback;\n\n  /**\n   * The constructor takes two arguments, a `callback`, which is called\n   * whenever the position of an observed element changes and an `options` object.\n   * The callback function takes an array of `PositionObserverEntry` objects\n   * as its only argument, but it's not required.\n   *\n   * @param callback the callback that applies to all targets of this observer\n   * @param options the options of this observer\n   */\n  constructor(\n    callback: PositionObserverCallback,\n    options?: Partial<PositionObserverOptions>,\n  ) {\n    if (!isFunction(callback)) {\n      throw new Error(`${errorString}: ${callback} is not a function.`);\n    }\n    this.entries = new Map();\n    this._callback = callback;\n    this._root = isElement(options?.root)\n      ? options.root\n      /* istanbul ignore next @preserve */\n      : document?.documentElement;\n    this._tick = 0;\n  }\n\n  /**\n   * Start observing the position of the specified element.\n   * If the element is not currently attached to the DOM,\n   * it will NOT be added to the entries.\n   *\n   * @param target an `Element` target\n   */\n  public observe = (target: Element) => {\n    if (!isElement(target)) {\n      throw new Error(\n        `${errorString}: ${target} is not an instance of Element.`,\n      );\n    }\n\n    /* istanbul ignore else @preserve - a guard must be set */\n    if (!this._root.contains(target)) return;\n\n    // define a new entry\n    // push the entry into the queue\n    this._new(target).then(({ boundingClientRect }) => {\n      /* istanbul ignore else @preserve - don't allow duplicate entries */\n      if (boundingClientRect && !this.getEntry(target)) {\n        const { clientWidth, clientHeight } = this._root;\n\n        this.entries.set(target, {\n          target,\n          boundingClientRect,\n          clientWidth,\n          clientHeight,\n        });\n      }\n\n      /* istanbul ignore else @preserve */\n      if (!this._tick) this._tick = requestAnimationFrame(this._runCallback);\n    });\n  };\n\n  /**\n   * Stop observing the position of the specified element.\n   *\n   * @param target an `Element` target\n   */\n  public unobserve = (target: Element) => {\n    /* istanbul ignore else @preserve */\n    if (this.entries.has(target)) this.entries.delete(target);\n  };\n\n  /**\n   * Private method responsible for all the heavy duty,\n   * the observer's runtime.\n   */\n  private _runCallback = () => {\n    /* istanbul ignore if @preserve - a guard must be set */\n    if (!this.entries.size) {\n      this._tick = 0;\n      return;\n    }\n    const { clientWidth, clientHeight } = this._root;\n\n    const queue = new Promise<PositionObserverEntry[]>((resolve) => {\n      const updates: PositionObserverEntry[] = [];\n      this.entries.forEach(\n        (\n          {\n            target,\n            boundingClientRect: oldBoundingBox,\n            clientWidth: oldWidth,\n            clientHeight: oldHeight,\n          },\n        ) => {\n          /* istanbul ignore if @preserve - a guard must be set when target has been removed */\n          if (!this._root.contains(target)) return;\n\n          this._new(target).then(({ boundingClientRect, isIntersecting }) => {\n            /* istanbul ignore if @preserve - make sure to only count visible entries */\n            if (!isIntersecting) return;\n            const { left, top } = boundingClientRect;\n\n            /* istanbul ignore else @preserve - only schedule entries that changed position */\n            if (\n              oldBoundingBox.top !== top || oldBoundingBox.left !== left ||\n              oldWidth !== clientWidth || oldHeight !== clientHeight\n            ) {\n              const newEntry = {\n                target,\n                boundingClientRect,\n                clientHeight,\n                clientWidth,\n              };\n              this.entries.set(target, newEntry);\n              updates.push(newEntry);\n            }\n          });\n        },\n      );\n\n      resolve(updates);\n    });\n\n    this._tick = requestAnimationFrame(async () => {\n      // execute the queue\n      const updates = await queue;\n\n      // only execute the callback if position actually changed\n      /* istanbul ignore else @preserve */\n      if (updates.length) this._callback(updates, this);\n\n      this._runCallback();\n    });\n  };\n\n  /**\n   * Check intersection status and resolve it\n   * right away.\n   *\n   * @param target an `Element` target\n   */\n  private _new = (target: Element) => {\n    return new Promise<IntersectionObserverEntry>((resolve) => {\n      const intersectionObserver = new IntersectionObserver(\n        ([entry], ob) => {\n          ob.disconnect();\n\n          resolve(entry);\n        },\n      );\n\n      intersectionObserver.observe(target);\n    });\n  };\n\n  /**\n   * Find the entry for a given target.\n   *\n   * @param target an `HTMLElement` target\n   */\n  public getEntry = (target: Element) => this.entries.get(target);\n\n  /**\n   * Immediately stop observing all elements.\n   */\n  public disconnect = () => {\n    cancelAnimationFrame(this._tick);\n    this.entries.clear();\n    this._tick = 0;\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;cAEa;;;;ACiBb,MAAM,cAAc;;;;;AAMpB,IAAqB,mBAArB,MAAsC;CACpC,AAAO;CACP,OAAc,UAAU;CACxB,AAAQ;CACR,AAAQ;CACR,AAAQ;;;;;;;;;;CAWR,YACEA,UACAC,SACA;AACA,OAAK,gCAAW,SAAS,CACvB,OAAM,IAAI,OAAO,EAAE,YAAY,IAAI,SAAS;AAE9C,OAAK,0BAAU,IAAI;AACnB,OAAK,YAAY;AACjB,OAAK,QAAQ,+BAAU,SAAS,KAAK,GACjC,QAAQ,OAER,UAAU;AACd,OAAK,QAAQ;CACd;;;;;;;;CASD,AAAO,UAAU,CAACC,WAAoB;AACpC,OAAK,+BAAU,OAAO,CACpB,OAAM,IAAI,OACP,EAAE,YAAY,IAAI,OAAO;;AAK9B,OAAK,KAAK,MAAM,SAAS,OAAO,CAAE;AAIlC,OAAK,KAAK,OAAO,CAAC,KAAK,CAAC,EAAE,oBAAoB,KAAK;;AAEjD,OAAI,uBAAuB,KAAK,SAAS,OAAO,EAAE;IAChD,MAAM,EAAE,aAAa,cAAc,GAAG,KAAK;AAE3C,SAAK,QAAQ,IAAI,QAAQ;KACvB;KACA;KACA;KACA;IACD,EAAC;GACH;;AAGD,QAAK,KAAK,MAAO,MAAK,QAAQ,sBAAsB,KAAK,aAAa;EACvE,EAAC;CACH;;;;;;CAOD,AAAO,YAAY,CAACA,WAAoB;;AAEtC,MAAI,KAAK,QAAQ,IAAI,OAAO,CAAE,MAAK,QAAQ,OAAO,OAAO;CAC1D;;;;;CAMD,AAAQ,eAAe,MAAM;;AAE3B,OAAK,KAAK,QAAQ,MAAM;AACtB,QAAK,QAAQ;AACb;EACD;EACD,MAAM,EAAE,aAAa,cAAc,GAAG,KAAK;EAE3C,MAAM,QAAQ,IAAI,QAAiC,CAAC,YAAY;GAC9D,MAAMC,UAAmC,CAAE;AAC3C,QAAK,QAAQ,QACX,CACE,EACE,QACA,oBAAoB,gBACpB,aAAa,UACb,cAAc,WACf,KACE;;AAEH,SAAK,KAAK,MAAM,SAAS,OAAO,CAAE;AAElC,SAAK,KAAK,OAAO,CAAC,KAAK,CAAC,EAAE,oBAAoB,gBAAgB,KAAK;;AAEjE,UAAK,eAAgB;KACrB,MAAM,EAAE,MAAM,KAAK,GAAG;;AAGtB,SACE,eAAe,QAAQ,OAAO,eAAe,SAAS,QACtD,aAAa,eAAe,cAAc,cAC1C;MACA,MAAM,WAAW;OACf;OACA;OACA;OACA;MACD;AACD,WAAK,QAAQ,IAAI,QAAQ,SAAS;AAClC,cAAQ,KAAK,SAAS;KACvB;IACF,EAAC;GACH,EACF;AAED,WAAQ,QAAQ;EACjB;AAED,OAAK,QAAQ,sBAAsB,YAAY;GAE7C,MAAM,UAAU,MAAM;;AAItB,OAAI,QAAQ,OAAQ,MAAK,UAAU,SAAS,KAAK;AAEjD,QAAK,cAAc;EACpB,EAAC;CACH;;;;;;;CAQD,AAAQ,OAAO,CAACD,WAAoB;AAClC,SAAO,IAAI,QAAmC,CAAC,YAAY;GACzD,MAAM,uBAAuB,IAAI,qBAC/B,CAAC,CAAC,MAAM,EAAE,OAAO;AACf,OAAG,YAAY;AAEf,YAAQ,MAAM;GACf;AAGH,wBAAqB,QAAQ,OAAO;EACrC;CACF;;;;;;CAOD,AAAO,WAAW,CAACA,WAAoB,KAAK,QAAQ,IAAI,OAAO;;;;CAK/D,AAAO,aAAa,MAAM;AACxB,uBAAqB,KAAK,MAAM;AAChC,OAAK,QAAQ,OAAO;AACpB,OAAK,QAAQ;CACd;AACF"}